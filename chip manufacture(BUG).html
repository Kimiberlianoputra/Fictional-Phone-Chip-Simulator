<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Prime Edition — Ultimate Fictional Phone Chip Simulator (Deluxe)</title>

<!-- Tailwind CDN for utility-first CSS styling -->
<script src="https://cdn.tailwindcss.com"></script>
<!-- Chart.js CDN for interactive data visualization -->
<script src="https://cdn.jsdelivr.net/npm/chart.js@4.3.0/dist/chart.umd.min.js"></script>

<style>
  /* Custom CSS variables for consistent theming */
  :root {
    --bg:#071129;
    --panel:#071a2a;
    --muted:#9fb0c6;
    --accent:#7c3aed;
    --glass: rgba(255,255,255,0.03);
  }
  /* Basic body and HTML styling */
  html,body {height:100%}
  body {
    background:linear-gradient(180deg,#031026 0%, #071129 60%);
    color:#dbeafe;
    font-family:Inter,ui-sans-serif,system-ui,-apple-system,"Segoe UI",Roboto,"Helvetica Neue",Arial;
  }
  /* Styling for card components */
  .card {
    background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
    border:1px solid rgba(255,255,255,0.03);
    padding:1rem;
    border-radius:12px;
  }
  /* Monospace font for code and data */
  .mono {font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, "Roboto Mono", monospace}
  /* Small text size utility */
  .small {font-size:.82rem}
  /* Styling for tags */
  .tag {
    background:rgba(255,255,255,0.03);
    padding:.18rem .5rem;
    border-radius:6px;
    border:1px solid rgba(255,255,255,0.02);
    font-size:.78rem;
  }
  /* Code block styling */
  .code {
    background:#050914;
    border-radius:10px;
    padding:12px;
    font-family:ui-monospace, SFMono-Regular, Menlo, monospace;
    font-size:.85rem;
    line-height:1.45;
    color:#dbeafe;
    border:1px solid rgba(255,255,255,0.03);
    overflow:auto;
    max-height:360px;
  }
  /* Base button styling */
  .btn {padding:.55rem .85rem;border-radius:.6rem;font-weight:700}
  /* Primary button styling */
  .btn-primary {background:linear-gradient(90deg,var(--accent),#4f46e5);color:white}
  /* Ghost button styling */
  .btn-ghost {background:transparent;border:1px solid rgba(255,255,255,0.03);color:var(--muted)}
  /* Key Performance Indicator (KPI) styling */
  .kpi {
    background:linear-gradient(90deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
    padding:.6rem;
    border-radius:8px;
    border:1px solid rgba(255,255,255,0.02);
  }
  /* Help text styling */
  .help {color:var(--muted);font-size:.85rem}
  /* Loading overlay styling */
  .loadingOverlay {
    position:fixed;
    inset:0;
    display:flex;
    align-items:center;
    justify-content:center;
    background:linear-gradient(180deg, rgba(2,6,23,0.6), rgba(2,6,23,0.85));
    z-index:60;
    backdrop-filter: blur(4px);
    display:none; /* Hidden by default */
  }
  /* Spinner animation for loading states */
  .spinner {
    width:46px;
    height:46px;
    border-radius:999px;
    border:5px solid rgba(255,255,255,0.12);
    border-top-color:#fff;
    animation:spin 1s linear infinite;
  }
  /* Keyframe animation for spinner */
  @keyframes spin{to{transform:rotate(360deg)}}
  /* Scrollable area styling */
  .overflow-scroll-y {max-height:520px;overflow:auto;padding-right:8px}
  /* Chip list item styling */
  .chip-list-item {
    display:flex;
    align-items:center;
    gap:.5rem;
    padding:.45rem .6rem;
    border-radius:8px;
    border:1px solid rgba(255,255,255,0.02);
    background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.00));
  }
  /* Temperature bar styling */
  .temp-bar {
    height:8px;
    border-radius:4px;
    background:linear-gradient(90deg, #3b82f6, #ef4444);
    margin-top:4px;
  }
  /* Throttle indicator bar styling */
  .throttle-indicator {
    height:8px;
    border-radius:4px;
    background:linear-gradient(90deg, #10b981, #f59e0b);
    margin-top:4px;
  }
  /* Warning text styling */
  .warning {color:#f59e0b;font-weight:600}
  /* Success text styling */
  .success {color:#10b981;font-weight:600}
  /* Input range slider styling */
  .input-range {width:100%;margin-top:6px}
  /* Core preview layout */
  .core-preview {display:flex;gap:4px;margin-top:8px}
  /* Individual core styling */
  .core {width:12px;height:12px;border-radius:50%}
  /* Specific core colorings */
  .core-perf{background:#7c3aed}
  .core-eff{background:#3b82f6}
  .core-ai{background:#10b981}
  .core-hyper{background:#f59e0b}
  /* Core label styling */
  .core-label{display:flex;align-items:center;gap:4px;font-size:.75rem}
  /* Performance meter bar styling */
  .perf-meter {
    height:8px;
    background:rgba(255,255,255,0.1);
    border-radius:4px;
    overflow:hidden;
    margin-top:4px;
  }
  /* Performance fill inside meter */
  .perf-fill {height:100%;background:linear-gradient(90deg,#7c3aed,#4f46e5)}
  /* Styling for full-width inputs, selects, and textareas */
  input.w-full,
  select.w-full,
  textarea.w-full {
    color: #222 !important;
    background-color: #fff !important;
    border-color: #ccc !important;
  }

  /* Custom Modal Styles for pop-up dialogs */
  .custom-modal-overlay {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.7);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 100;
      backdrop-filter: blur(3px);
  }
  .custom-modal-content {
      background: var(--panel);
      border: 1px solid rgba(255,255,255,0.1);
      border-radius: 12px;
      padding: 24px;
      width: 90%;
      max-width: 400px;
      box-shadow: 0 8px 30px rgba(0, 0, 0, 0.4);
      color: #dbeafe;
      text-align: left;
  }
  .custom-modal-content h3 {
      font-size: 1.25rem;
      font-weight: 600;
      margin-bottom: 16px;
  }
  .custom-modal-content p {
      margin-bottom: 20px;
      font-size: 0.95rem;
      line-height: 1.5;
  }
  .custom-modal-content input[type="text"] {
      width: 100%;
      padding: 10px;
      border-radius: 6px;
      border: 1px solid rgba(255,255,255,0.1);
      background-color: rgba(255,255,255,0.05);
      color: #dbeafe;
      margin-bottom: 20px;
  }
  .custom-modal-actions {
      display: flex;
      justify-content: flex-end;
      gap: 12px;
  }
  .custom-modal-actions .btn {
      padding: 8px 18px;
  }

  /* Thermal Runaway Effect (visual warning for critical temperatures) */
  .thermal-critical {
      animation: criticalPulse 1s infinite alternate;
  }
  /* Keyframe animation for thermal critical state */
  @keyframes criticalPulse {
      from { background-color: #031026; }
      to { background-color: #4b0000; } /* Dark red */
  }
</style>
</head>
<body>
<div class="max-w-7xl mx-auto p-6">
  <header class="flex items-start justify-between gap-4 mb-6">
    <div>
      <h1 class="text-2xl md:text-3xl font-bold">Prime Edition — Ultimate Fictional Phone Chip Simulator</h1>
      <p class="small help mt-1">Design chips, edit math architecture, test AI layers, explore battery & thermal behavior, export builds.</p>
    </div>
    <div class="flex items-center gap-3">
      <button id="btnQuickHelp" class="btn btn-ghost small">Quick Help</button>
      <button id="btnTuningGuide" class="btn btn-ghost small">Tuning Guide</button>
      <button id="btnAlgorithmTutorial" class="btn btn-ghost small">Algorithm Tutorial</button>
      <button id="btnAbout" class="btn btn-ghost small">About</button>
    </div>
  </header>

  <main class="grid grid-cols-1 xl:grid-cols-3 gap-6">
    <!-- Left Column: Controls and Algorithm Editor -->
    <section class="col-span-2 space-y-4">
      <div class="card">
        <div class="flex items-center justify-between mb-3">
          <div>
            <h2 class="font-semibold text-lg">Chip Topology & Silicon</h2>
            <p class="help">Add performance, efficiency, AI and hyper cores. Adjust clocks, process node, memory, and cooling budget.</p>
          </div>
          <div class="flex gap-2 items-center">
            <span class="tag mono small" id="chipTag">Unsaved</span>
            <button id="btnPreset" class="btn btn-ghost small">Presets</button>
            <div class="relative inline-block">
              <button id="btnSave" class="btn btn-primary small">Save</button>
            </div>
          </div>
        </div>

        <div class="grid grid-cols-1 md:grid-cols-3 gap-3">
          <div>
            <label class="small">Performance Cores</label>
            <input id="numPerf" type="number" class="w-full" min="0" value="3" />
          </div>
          <div>
            <label class="small">Efficiency Cores</label>
            <input id="numEff" type="number" class="w-full" min="0" value="4" />
          </div>
          <div>
            <label class="small">Hyper Cores</label>
            <input id="numHyper" type="number" class="w-full" min="0" value="1" />
          </div>
          <div>
            <label class="small">GPU Cores</label>
            <input id="numGPU" type="number" class="w-full" min="0" value="8" />
          </div>
          <div>
            <label class="small">AI (NPU) Cores</label>
            <input id="numAI" type="number" class="w-full" min="0" value="2" />
          </div>
          <div>
            <label class="small">Perf. Core Clock (GHz)</label>
            <input id="clkPerf" type="number" step="0.05" class="w-full" min="0.4" value="3.0" />
          </div>
          <div>
            <label class="small">Eff. Core Clock (GHz)</label>
            <input id="clkEff" type="number" step="0.05" class="w-full" min="0.4" value="2.0" />
          </div>
          <div>
            <label class="small">Hyper Core Clock (GHz)</label>
            <input id="clkHyper" type="number" step="0.05" class="w-full" min="0.4" value="2.5" />
          </div>
          <div>
            <label class="small">GPU Clock (GHz)</label>
            <input id="clkGPU" type="number" step="0.05" class="w-full" min="0.5" value="1.5" />
          </div>
          <div>
            <label class="small">NPU Clock (GHz)</label>
            <input id="clkNPU" type="number" step="0.05" class="w-full" min="0.3" value="1.4" />
          </div>
          <div>
            <label class="small">Shader Units</label>
            <input id="numShaders" type="number" class="w-full" min="0" value="192" />
          </div>
          <div>
            <label class="small">Shader Complexity</label>
            <select id="shaderComplexity" class="w-full">
              <option value="low">Low</option>
              <option value="medium" selected>Medium</option>
              <option value="high">High</option>
            </select>
          </div>
          <div>
            <label class="small">Process Node (nm)</label>
            <input id="nodeNm" type="number" class="w-full" min="3" max="10" step="1" value="4" />
            <div class="perf-meter">
              <div id="nodePerfMeter" class="perf-fill" style="width:75%"></div>
            </div>
          </div>
          <div>
            <label class="small">System Memory (MB)</label>
            <input id="sysMem" type="number" class="w-full" min="512" value="8192" />
          </div>
          <div>
            <label class="small">Battery Capacity (mAh)</label>
            <input id="battmAh" type="number" class="w-full" min="1000" value="5000" />
          </div>
          <div>
            <label class="small">Cooling Budget (W)</label>
            <input id="coolingW" type="number" class="w-full" min="1.5" step="0.1" value="7.5" />
          </div>
          <div class="mt-4">
            <label for="thermalLimit" class="small">Thermal Limit (°C)</label>
            <input id="thermalLimit" type="number" class="w-full" min="60" max="120" placeholder="Leave blank for auto" />
            <div class="small help">Chip will throttle above this temperature</div>
          </div>
          <div>
            <label class="small">DVFS Cap (MHz max)</label>
            <input id="dvfsCap" type="range" min="800" max="4200" step="50" value="4200" class="input-range" />
            <div class="flex items-center justify-between small help mt-1">
              <span id="dvfsVal">4200 MHz</span>
              <span class="help">DVFS reduces clocks under thermal risk</span>
            </div>
          </div>
          <div>
            <label class="small">Quantization (TOPS/GFLOPS)</label>
            <select id="quantMode" class="w-full">
              <option value="int8">int8 (highest TOPS)</option>
              <option value="fp16" selected>fp16 (balanced)</option>
              <option value="fp32">fp32 (higher precision, lower TOPS)</option>
            </select>
          </div>
        </div>

        <div class="core-preview">
          <div class="core-label"><div class="core core-perf"></div> Perf</div>
          <div class="core-label"><div class="core core-eff"></div> Eff</div>
          <div class="core-label"><div class="core core-ai"></div> AI</div>
          <div class="core-label"><div class="core core-hyper"></div> Hyper</div>
        </div>

        <div class="mt-4 grid grid-cols-1 md:grid-cols-3 gap-3">
          <div>
            <label class="small">Matrix Size (N)</label>
            <input id="matN" type="number" class="w-full" min="16" max="1024" value="256" />
          </div>
          <div>
            <label class="small">NN Layers</label>
            <input id="layers" type="number" class="w-full" min="1" max="24" value="6" />
          </div>
          <div>
            <label class="small">Simulated Memory for Weight Bits</label>
            <select id="weightFormat" class="w-full">
              <option value="fp32">weights fp32</option>
              <option value="fp16" selected>weights fp16</option>
              <option value="int8">weights int8</option>
            </select>
          </div>
        </div>

        <div class="mt-4 flex gap-3 items-center flex-wrap">
          <button id="btnRun" class="btn btn-primary">Run Simulation</button>
          <button id="btnReset" class="btn btn-ghost">Reset</button>
          <button id="btnExportJSON" class="btn btn-ghost">Export JSON</button>
          <button id="btnCompare" class="btn btn-ghost">Compare Saved</button>
          <button id="btnCostOptimize" class="btn btn-ghost">Cost Optimize</button>
          <div class="ml-auto small help">Results update when you press <strong>Run</strong></div>
        </div>
        <div class="mt-4 flex items-center gap-3">
            <input type="checkbox" id="disableThrottling" class="form-checkbox h-4 w-4 text-blue-600 rounded" />
            <label for="disableThrottling" class="small text-gray-400">Disable Thermal Throttling</label>
        </div>
         <div class="mt-4">
            <label for="workloadProfile" class="small">Workload Profile</label>
            <select id="workloadProfile" class="w-full">
              <option value="mixed">Mixed Use (Default)</option>
              <option value="gaming">Gaming Mode</option>
              <option value="videoEditing">Video Editing Render</option>
              <option value="socialMedia">Social Media Browsing</option>
              <option value="idle">Idle</option>
            </select>
          </div>
      </div>

      <!-- Algorithm editor -->
      <div class="card">
        <div class="flex items-center justify-between mb-2">
          <div>
            <h3 class="font-semibold">Editable Math Architecture (JSON)</h3>
            <p class="help">Define your algorithm as JSON. Select core operations (matrix multiply, activation, residual) and their parameters. See the "Algorithm Tutorial" for help.</p>
          </div>
          <div class="flex gap-2">
            <button id="btnLoadDefaultAlgorithm" class="btn btn-ghost small">Load Default Algorithm</button>
            <button id="btnLoadBlockedAlgorithm" class="btn btn-ghost small">Load Blocked Algorithm</button>
            <button id="btnLoadBatteryOptimizedAlgorithm" class="btn btn-ghost small">Load Battery Optimized Algorithm</button>
            <button id="btnBeautifyAlgorithm" class="btn btn-ghost small">Beautify JSON</button>
          </div>
        </div>

        <textarea id="algorithmEditor" class="code" rows="15" spellcheck="false">{
  "layers": 8,
  "sequence": [
    {
      "type": "matrixMultiply",
      "method": "naive"
    },
    {
      "type": "activation",
      "function": "relu"
    },
    {
      "type": "matrixMultiply",
      "method": "naive"
    },
    {
      "type": "activation",
      "function": "sigmoid"
    },
    {
      "type": "conditionalResidual",
      "frequency": 3,
      "enabled": true
    }
  ]
}</textarea>
        <!-- Algorithm Editor Hints -->
        <div id="algorithmHints" class="small help mono mt-2 p-3 bg-gray-900 rounded-md border border-gray-800">
          <p class="text-white font-semibold mb-1">Supported Algorithm Operations:</p>
          <ul class="list-disc list-inside ml-2 text-gray-400">
            <li><strong class="text-blue-300">"type": "matrixMultiply"</strong>
              <ul class="list-circle list-inside ml-4">
                <li><strong class="text-emerald-300">"method": "naive"</strong></li>
                <li><strong class="text-emerald-300">"method": "blocked"</strong> (add <code class="text-orange-300">"blockSize": [number]</code> e.g. 32)</li>
              </ul>
            </li>
            <li><strong class="text-blue-300">"type": "activation"</strong>
              <ul class="list-circle list-inside ml-4">
                <li><strong class="text-emerald-300">"function": "relu"</strong></li>
                <li><strong class="text-emerald-300">"function": "sigmoid"</strong></li>
                <li><strong class="text-emerald-300">"function": "tanh"</strong></li>
              </ul>
            </li>
            <li><strong class="text-blue-300">"type": "conditionalResidual"</strong>
              <ul class="list-circle list-inside ml-4">
                <li><strong class="text-emerald-300">"enabled": [boolean]</strong> (true/false)</li>
                <li><strong class="text-emerald-300">"frequency": [positive number]</strong> (e.g., 2 for every 2nd layer)</li>
              </ul>
            </li>
            <li><strong class="text-blue-300">"architecturalHints"</strong> (top-level, optional)
              <ul class="list-circle list-inside ml-4">
                <li><strong class="text-emerald-300">"optimalDataBlockSizeKB": [number | "auto"]</strong> (e.g., 512 or "auto")</li>
              </ul>
            </li>
          </ul>
        </div>
        <div class="mt-3 flex gap-3">
          <div class="ml-auto small help">Algorithm defined by JSON is executed in a sandbox. Ensure valid JSON format.</div>
        </div>
      </div>

      <!-- Chart & extra toggles -->
      <div class="card">
        <div class="flex items-center justify-between mb-3">
          <h3 class="font-semibold">Performance / Watt Chart</h3>
          <div class="help small">Shows perf-per-watt across light/mixed/heavy profiles.</div>
        </div>
        <canvas id="ppwChart" style="height:220px; max-height:300px;"></canvas>
        <div id="chartDescriptions" class="mt-3 text-sm text-gray-400"></div>
        <div class="mt-3 flex gap-3">
          <button id="btnRefreshChart" class="btn btn-ghost small">Refresh Chart</button>
          <button id="btnToggleChartMode" class="btn btn-ghost small">Toggle Linear / Log</button>
          <div class="ml-auto help small">Chart uses Chart.js</div>
        </div>
      </div>

    </section>

    <!-- Right Column: Results & Saved Chips -->
    <aside class="space-y-4">
      <div class="card">
        <h3 class="font-semibold mb-2">Live KPIs</h3>
        <div class="grid grid-cols-1 gap-2">
          <div class="kpi">
            <div class="flex items-center justify-between"><div class="small">Algorithm Time (R0)</div><div id="k_time" class="font-bold mono">-- ms</div></div>
            <div class="small help">Lower is better — shows code runtime for your math architecture</div>
          </div>

          <div class="kpi">
            <div class="flex items-center justify-between"><div class="small">Effective GFLOPS (R2)</div><div id="k_gflops" class="font-bold mono">--</div></div>
            <div class="small help">Combined CPU/Hyper/Eff cores, tuned by algorithm efficiency & throttling</div>
          </div>

          <div class="kpi">
            <div class="flex items-center justify-between"><div class="small">Effective TOPS (R2)</div><div id="k_tops" class="font-bold mono">--</div></div>
            <div class="small help">AI core throughput — quantization affects this strongly</div>
          </div>

          <div class="kpi">
            <div class="flex items-center justify-between"><div class="small">Peak Power</div><div id="k_power" class="font-bold mono">-- W</div></div>
            <div class="small help">Estimated peak device power under sustained load</div>
          </div>

          <div class="kpi">
            <div class="flex items-center justify-between"><div class="small">Thermal (°C)</div><div id="k_temp" class="font-bold mono">--</div></div>
            <div id="tempBar" class="temp-bar" style="width:0%"></div>
            <div class="small help mt-1">Post-throttling temperature estimate</div>
          </div>

          <div class="kpi">
            <div class="flex items-center justify-between"><div class="small">Throttle Level</div><div id="k_throttle" class="font-bold mono">--%</div></div>
            <div id="throttleBar" class="throttle-indicator" style="width:0%"></div>
            <div class="small help mt-1">Performance reduction due to thermal limits</div>
          </div>

          <div class="kpi">
            <div class="flex items-center justify-between"><div class="small">Battery (mixed)</div><div id="k_batt" class="font-bold mono">-- h</div></div>
            <div class="small help">Estimated battery life for mixed use</div>
          </div>

          <div class="kpi">
            <div class="flex items-center justify-between"><div class="small">Composite Benchmark (R2)</div><div id="k_bench" class="font-bold mono">--</div></div>
            <div class="small help">Abstract composite score (comparable across chips)</div>
          </div>

          <div class="kpi">
            <div class="flex items-center justify-between"><div class="small">Effective GPU TFLOPS (R2)</div><div id="k_gpu" class="font-bold mono">--</div></div>
            <div class="small help">GPU throughput for graphics and compute tasks</div>
          </div>
        </div>
      </div>

      <div class="card">
          <h3 class="font-semibold">Chip Price Estimate</h3>
          <div id="p_estimate" class="small help">Run the simulation to generate recommendations and a plain-language summary.</div>
      </div>

      <div class="card">
        <div class="flex items-center justify-between mb-2">
          <h3 class="font-semibold">Saved Chips</h3>
          <div class="flex gap-2">
            <button id="btnListSave" class="btn btn-ghost small">List</button>
            <button id="btnClearAll" class="btn btn-ghost small">Clear</button>
          </div>
        </div>
        <div id="savedList" class="overflow-scroll-y" style="max-height:340px">
          <!-- Populated dynamically by JavaScript -->
        </div>
      </div>

      <div class="card">
        <h3 class="font-semibold">Summary / Advice</h3>
        <div id="k_summary" class="small help">Run the simulation to generate recommendations and a plain-language summary.</div>
      </div>
    </aside>
  </main>

  <footer class="mt-6 small help text-center">Made for creative chip design & play. Not an actual hardware simulator — abstractions are tuned to be believable and fun.</footer>
</div>

<!-- Loading overlay for long simulations -->
<div id="loadingOverlay" class="loadingOverlay">
  <div class="flex flex-col items-center gap-4">
    <div class="spinner"></div>
    <div class="small">Running heavy simulation — please wait...</div>
    <div id="progressText" class="small mono">Initializing...</div>
  </div>
</div>

<!-- Custom Modal HTML Structure for alerts and confirms -->
<div id="customModalOverlay" class="custom-modal-overlay hidden">
  <div class="custom-modal-content">
    <h3 id="customModalTitle"></h3>
    <p id="customModalMessage"></p>
    <input type="text" id="customModalInput" class="hidden" placeholder="Enter value..." />
    <div class="custom-modal-actions">
      <button id="customModalCancel" class="btn btn-ghost small hidden">Cancel</button>
      <button id="customModalConfirm" class="btn btn-primary small">OK</button>
    </div>
  </div>
</div>

<!-- Existing Tuning Guide Modal -->
<div id="tuningGuideModal" class="custom-modal-overlay hidden">
  <div class="custom-modal-content max-w-xl overflow-y-auto max-h-[90vh]">
    <h3 class="text-xl font-bold mb-4">Chip Tuning 101: Boost Your Phone's Brain! 🧠</h3>
    <p class="mb-4">Welcome, future Chip Architect! This guide will help you understand how to make your fictional phone chip perform its best. It's all about balancing **Hardware** (the chip's parts) and **Software** (the code it runs).</p>

    <h4 class="font-semibold text-lg mb-2">1. Hardware: The Muscles 💪</h4>
    <p class="mb-2">This is the physical stuff – how many cores, how fast they run, how much memory, and how well it stays cool.</p>
    <ul class="list-disc list-inside mb-4 text-sm">
      <li><strong>Cores (Performance, Efficiency, AI, Hyper, GPU):</strong> More cores mean more power! But watch out, more cores cost more money and generate more heat.
        <ul class="list-circle list-inside ml-4">
          <li>**Better:** More cores for specific tasks (e.g., more AI cores for AI apps).</li>
          <li>**Worse:** Too many cores can make your chip expensive and hot.</li>
        </ul>
      </li>
      <li><strong>Clocks (GHz):):</strong> This is how fast your cores work. Faster clocks mean more speed!
        <ul class="list-circle list-inside ml-4">
          <li>**Better:** Higher clock speeds for faster processing.</li>
          <li>**Worse:** Too fast, and your chip gets super hot, leading to slowdowns (throttling) and draining the battery.</li>
        </ul>
      </li>
      <li><strong>Process Node (nm):):</strong> Think of this as how tiny the parts of your chip are. Smaller numbers (like 3nm) mean more advanced tech.
        <ul class="list-circle list-inside ml-4">
          <li>**Better:** Smaller nodes mean more power, less heat, and better efficiency.</li>
          <li>**Worse:** They are much more expensive to make!</li>
        </ul>
      </li>
      <li><strong>System Memory (MB):</strong> This is like your chip's short-term memory. It needs enough space to work on big tasks.
        <ul class="list-circle list-inside ml-4">
          <li>**Better:** Enough memory to handle complex calculations.</li>
          <li>**Worse:** Not enough memory will slow down your chip even if it's powerful. Too much is wasted cost.</li>
        </ul>
      </li>
      <li><strong>Cooling Budget (W):</strong> How well your phone can get rid of heat.
        <ul class="list-circle list-inside ml-4">
          <li>**Better:** More cooling keeps your chip running fast without overheating.
          <li>**Worse:** Not enough cooling means your chip will get hot and slow down a lot to protect itself.
        </ul>
      </li>
    </ul>

    <h4 class="font-semibold text-lg mb-2">2. Software: The Brains 🧠</h4>
    <p class="mb-2">This is about how smart your chip's programs (your code in the "Editable Math Architecture" box) are at using the hardware.</p>
    <ul class="list-disc list-inside mb-4 text-sm">
      <li><strong>Algorithm Time (R0):</strong> This shows how fast your code runs on a perfect chip.
        <ul class="list-circle list-inside ml-4">
          <li>**Better:** Writing smarter, more efficient code makes this time lower.</li>
          <li>**Worse:** Sloppy code wastes your chip's power.</li>
        </ul>
      </li>
      <li><strong>Algorithm Efficiency:</strong> How well your code gets the job done with the fewest steps.
        <ul class="list-circle list-inside ml-4">
          <li>**Better:** Closer to 100% means your code is super efficient, getting the most out of your chip.</li>
          <li>**Worse:** If your code does unnecessary work, this percentage drops, wasting your chip's power.</li>
        </ul>
      </li>
      <li><strong>Architectural Alignment:</strong> Does your code's memory needs match your chip's memory?
        <ul class="list-circle list-inside ml-4">
          <li>**Better:** When your code's "data blocks" fit nicely in the chip's memory, everything runs smoothly.</li>
          <li>**Worse:** If your code needs data chunks that are too big for the chip's memory, it slows down a lot.</li>
        </ul>
      </li>
    </ul>

    <h4 class="font-semibold text-lg mb-2">3. The Performance Journey (R0 → R1 → R2) 🚀</h4>
    <ul class="list-disc list-inside mb-4 text-sm">
      <li><strong>R0 (Raw Code Speed):</strong> How fast your written algorithm runs. You make this better by writing smarter code.</li>
      <li><strong>R1 (Hardware's Max Potential):</strong> How fast your chip *could* be based on its design (cores, clocks).</li>
      <li><strong>R2 (Real-World Speed):</strong> This is what you actually get! It's your chip's **Max Potential (R1)**, made better by your **Smart Code (R0)** and **Good Memory Fit**, but slowed down if your chip gets **Too Hot**.</li>
    </ul>

    <h4 class="font-semibold text-lg mb-2">The Golden Rule: Balance is Key! ✨</h4>
    <p class="mb-4 text-sm">A chip with super-fast hardware but bad code, or a great algorithm on a chip that overheats, won't perform its best. **The goal is to make your hardware and software work together perfectly!** Experiment with both the top settings and the code to find the best balance for your ultimate phone chip!</p>

    <div class="custom-modal-actions">
      <button id="closeTuningGuide" class="btn btn-primary small">Got It!</button>
    </div>
  </div>
</div>

<script>
(function(){
  // Helper function to get an element by ID, with a warning if not found.
  const $ = id => {
    const element = document.getElementById(id);
    if (!element) {
      console.warn(`Element with ID '${id}' not found. This might cause issues.`);
    }
    return element;
  };

  // --- Custom Modal Functions ---
  /**
   * Displays a custom alert dialog.
   * @param {string} message - The message to display.
   * @param {string} [title='Notification'] - The title of the dialog.
   * @returns {Promise<void>} A promise that resolves when the user clicks OK.
   */
  function showCustomAlert(message, title = 'Notification') {
      return new Promise((resolve) => {
          const customModalTitle = $('customModalTitle');
          const customModalMessage = $('customModalMessage');
          const customModalInput = $('customModalInput');
          const customModalCancel = $('customModalCancel');
          const customModalConfirm = $('customModalConfirm');
          const customModalOverlay = $('customModalOverlay');

          if (customModalTitle) customModalTitle.innerText = title;
          if (customModalMessage) customModalMessage.innerText = message;
          if (customModalInput) customModalInput.classList.add('hidden');
          if (customModalCancel) customModalCancel.classList.add('hidden');
          if (customModalConfirm) customModalConfirm.innerText = 'OK';
          
          if (customModalConfirm) {
            customModalConfirm.onclick = () => {
                if (customModalOverlay) customModalOverlay.classList.add('hidden');
                resolve();
            };
          }
          if (customModalOverlay) customModalOverlay.classList.remove('hidden');
      });
  }

  /**
   * Displays a custom confirmation dialog, optionally with an input field.
   * @param {string} message - The message to display.
   * @param {string} [title='Confirm'] - The title of the dialog.
   * @param {Function} [onConfirm] - Callback function for confirmation. Receives input value if `inputValue` is true.
   * @param {Function} [onCancel] - Callback function for cancellation.
   * @param {boolean} [inputValue=false] - Whether to show an input field.
   * @returns {Promise<boolean>} A promise that resolves to true if confirmed, false if cancelled.
   */
  function showCustomConfirm(message, title = 'Confirm', onConfirm, onCancel, inputValue = false) {
      return new Promise((resolve) => {
          const customModalTitle = $('customModalTitle');
          const customModalMessage = $('customModalMessage');
          const customModalInput = $('customModalInput');
          const customModalCancel = $('customModalCancel');
          const customModalConfirm = $('customModalConfirm');
          const customModalOverlay = $('customModalOverlay');

          if (customModalTitle) customModalTitle.innerText = title;
          if (customModalMessage) customModalMessage.innerText = message;
          if (customModalInput) {
            customModalInput.classList.toggle('hidden', !inputValue);
            customModalInput.value = ''; // Clear previous input
          }
          if (customModalCancel) customModalCancel.classList.remove('hidden');
          if (customModalConfirm) customModalConfirm.innerText = 'Confirm';

          if (customModalConfirm) {
            customModalConfirm.onclick = () => {
                if (customModalOverlay) customModalOverlay.classList.add('hidden');
                if (onConfirm) {
                    if (inputValue) {
                        onConfirm(customModalInput ? customModalInput.value.trim() : '');
                    } else {
                        onConfirm(true); // For simple confirmation
                    }
                }
                resolve(true); // Resolve the promise indicating user confirmed
            };
          }

          if (customModalCancel) {
            customModalCancel.onclick = () => {
                if (customModalOverlay) customModalOverlay.classList.add('hidden');
                if (onCancel) onCancel();
                resolve(false); // Resolve the promise indicating user cancelled
            };
          }
          if (customModalOverlay) customModalOverlay.classList.remove('hidden');
          if (inputValue && customModalInput) {
            customModalInput.focus();
          }
      });
  }
  // --- End Custom Modal Functions ---

  // --- Algorithm Core Functions (Internal, Hardcoded Implementations) ---
  // These functions are called by runArchitecture based on the JSON configuration.

  /**
   * Creates a square matrix filled with a fixed value.
   * @param {number} rows - Number of rows.
   * @param {number} cols - Number of columns.
   * @param {object} metrics - Object to track simulation metrics.
   * @returns {Float64Array[]} The created matrix.
   */
  function createMatrix(rows, cols, metrics){
    const A = new Array(rows);
    for(let i=0;i<rows;i++){
      const row = new Float64Array(cols);
      for(let j=0;j<cols;j++) row[j] = 0.5; // Fixed value for deterministic results
      A[i] = row;
    }
    metrics.peakBytes = Math.max(metrics.peakBytes, rows*cols*8);
    return A;
  }

  /**
   * Performs naive matrix multiplication.
   * @param {Float64Array[]} A - First matrix.
   * @param {Float64Array[]} B - Second matrix.
   * @param {object} metrics - Object to track simulation metrics.
   * @returns {Float64Array[]} Resultant matrix.
   * @throws {Error} If matrix dimensions are incompatible.
   */
  function multiplyMatricesNaive(A,B, metrics){
    const M = A.length, K = A[0].length, N = B[0].length;
    if(B.length !== K) throw new Error("Matrix dimension mismatch in naive multiplication");
    const C = new Array(M);
    for(let i=0;i<M;i++){
      const Ci = new Float64Array(N); 
      for(let k=0;k<K;k++){
        const aik = A[i][k];
        for(let j=0;j<N;j++){
          Ci[j] += aik * B[k][j];
          metrics.flops += 2 * 1.05; // Naive method incurs a 5% higher effective FLOP cost due to overhead
          metrics.iops += 2;
        }
      }
      C[i] = Ci;
    }
    metrics.peakBytes = Math.max(metrics.peakBytes, M*N*8);
    return C;
  }

  /**
   * Performs blocked matrix multiplication (cache-friendly).
   * @param {Float64Array[]} A - First matrix.
   * @param {Float64Array[]} B - Second matrix.
   * @param {object} metrics - Object to track simulation metrics.
   * @param {number} [blockSize=32] - Size of blocks for multiplication.
   * @returns {Float64Array[]} Resultant matrix.
   * @throws {Error} If matrix dimensions are incompatible.
   */
  function multiplyMatricesBlocked(A,B, metrics, blockSize = 32){
    const M = A.length, K = A[0].length, N = B[0].length;
    if(B.length !== K) throw new Error("Matrix dimension mismatch in blocked multiplication");
    const C = new Array(M);
    for(let i=0;i<M;i++){ C[i] = new Float64Array(N); }

    const block = blockSize;
    for(let ii=0; ii<M; ii += block){
      for(let kk=0; kk<K; kk += block){
        for(let jj=0; jj<N; jj += block){
          const iMax = Math.min(ii+block,M);
          const kMax = Math.min(kk+block,K);
          const jMax = Math.min(jj+block,N);
          for(let i=ii;i<iMax;i++){
            const Ai = A[i];
            const Ci = C[i];
            for(let k=kk;k<kMax;k++){
              const aik = Ai[k];
              const Bk = B[k];
              for(let j=jj;j<jMax;j++){
                Ci[j] += aik * Bk[j];
                metrics.flops += 2 * 1.0; // Blocked method has no additional effective FLOP cost
                metrics.iops += 2;
              }
            }
          }
        }
      }
    }
    metrics.peakBytes = Math.max(metrics.peakBytes, M*N*8);
    return C;
  }

  /**
   * Applies ReLU activation function to a matrix.
   * @param {Float64Array[]} M - Input matrix.
   * @param {object} metrics - Object to track simulation metrics.
   * @returns {Float64Array[]} Resultant matrix with ReLU applied.
   */
  function applyActivationRelu(M, metrics){
    const R = M.length, C = M[0].length;
    const O = new Array(R);
    for(let i=0;i<R;i++){
      const row = new Float64Array(C);
      for(let j=0;j<C;j++){
        row[j] = M[i][j] > 0 ? M[i][j] : 0; // ReLU
        metrics.flops += 1;
        metrics.iops += 1;
      }
      O[i] = row;
    }
    return O;
  }

  /**
   * Applies Sigmoid activation function to a matrix.
   * @param {Float64Array[]} M - Input matrix.
   * @param {object} metrics - Object to track simulation metrics.
   * @returns {Float64Array[]} Resultant matrix with Sigmoid applied.
   */
  function applyActivationSigmoid(M, metrics){
    const R = M.length, C = M[0].length;
    const O = new Array(R);
    for(let i=0;i<R;i++){
      const row = new Float64Array(C);
      for(let j=0;j<C;j++){
        row[j] = 1 / (1 + Math.exp(-M[i][j])); // Sigmoid
        metrics.flops += 1; // Approximation
        metrics.iops += 1; // Approximation
      }
      O[i] = row;
    }
    return O;
  }
  
  /**
   * Applies Tanh activation function to a matrix.
   * @param {Float64Array[]} M - Input matrix.
   * @param {object} metrics - Object to track simulation metrics.
   * @returns {Float64Array[]} Resultant matrix with Tanh applied.
   */
  function applyActivationTanh(M, metrics){
    const R = M.length, C = M[0].length;
    const O = new Array(R);
    for(let i=0;i<R;i++){
      const row = new Float64Array(C);
      for(let j=0;j<C;j++){
        row[j] = Math.tanh(M[i][j]); // Tanh
        metrics.flops += 1; // Approximation
        metrics.iops += 1; // Approximation
      }
      O[i] = row;
    }
    return O;
  }

  /**
   * Adds a residual connection (matrix addition).
   * @param {Float64Array[]} A - First matrix.
   * @param {Float64Array[]} B - Second matrix.
   * @param {object} metrics - Object to track simulation metrics.
   * @returns {Float64Array[]} Resultant matrix.
   * @throws {Error} If matrix dimensions are incompatible.
   */
  function addResidual(A, B, metrics){
    const R = A.length, C = A[0].length;
    if (R !== B.length || C !== B[0].length) {
        throw new Error("Matrix dimension mismatch for residual connection");
    }
    const O = new Array(R);
    for(let i=0;i<R;i++){
      const row = new Float64Array(C);
      for(let j=0;j<C;j++){
        row[j] = A[i][j] + B[i][j];
        metrics.flops += 1;
        metrics.iops += 1;
      }
      O[i] = row;
    }
    return O;
  }
  // --- End Algorithm Core Functions ---

  // Predefined JSON strings for different algorithm presets
  const DEFAULT_ALGORITHM_JSON = `{
  "layers": 8,
  "sequence": [
    {
      "type": "matrixMultiply",
      "method": "naive"
    },
    {
      "type": "activation",
      "function": "relu"
    },
    {
      "type": "matrixMultiply",
      "method": "naive"
    },
    {
      "type": "activation",
      "function": "sigmoid"
    },
    {
      "type": "conditionalResidual",
      "frequency": 3,
      "enabled": true
    }
  ]
}`;

  const BLOCKED_ALGORITHM_JSON = `{
  "layers": 6,
  "sequence": [
    { 
      "type": "matrixMultiply",
      "method": "blocked",
      "blockSize": 32
    },
    {
      "type": "activation",
      "function": "relu"
    }
  ],
  "architecturalHints": {
    "optimalDataBlockSizeKB": "auto"
  }
}`;

  const BATTERY_OPTIMIZED_ALGORITHM_JSON = `{
  "layers": 5,
  "sequence": [ 
    {
      "type": "matrixMultiply",
      "method": "blocked",
      "blockSize": 32
    },
    {
      "type": "activation",
      "function": "relu"
    },
    {
      "type": "conditionalResidual",
      "frequency": 1,
      "enabled": true
    }
  ],
  "architecturalHints": {
    "optimalDataBlockSizeKB": "auto"
  }
}`;

  // Default chip configuration values
  const DEFAULT = {
    numPerf: 3, numEff: 4, numAI: 2, numHyper: 1, numGPU: 8,
    clkPerf: 3.0, clkEff: 2.0, clkHyper: 2.5, clkNPU: 1.4, clkGPU: 1.5,
    nodeNm: 4, sysMem: 8192,
    battmAh: 5000, coolingW: 7.5, matN: 256, layers: 6,
    dvfsCapMHz: 4200, quantMode: 'fp16', weightFormat: 'fp16',
    disableThrottling: false, workloadProfile: 'mixed',
    thermalLimit: 85, // Default thermal limit added here
    algorithmJson: DEFAULT_ALGORITHM_JSON // Store the default algorithm JSON
  };

  let ppwChart = null; // Chart.js instance
  let chartIsLog = false; // Flag for chart y-axis scale
  let lastChartData = [0, 0, 0]; // Stores the last calculated chart data

  // Constants for chip simulation calculations
  const REF_NODE = 7; // Reference process node in nm
  const PERF_GFLOPS_PER_GHZ = 65;
  const EFF_GFLOPS_PER_GHZ  = 10;
  const HYPER_GFLOPS_PER_GHZ= 220;
  const AI_TOPS_PER_GHZ = 38;
  const GPU_TFLOPS_PER_CORE_BASE = 0.015;
  const POW_PERF_W = 0.32; // Power consumption per core type
  const POW_EFF_W  = 0.08;
  const POW_HYPER_W= 1.25;
  const POW_AI_W   = 0.26;
  const POW_GPU_W_PER_GHZ = 0.15;
  const POW_SHADER_W_PER_UNIT = 0.005;
  const BASE_PEAK_W = 2.2; // Base power consumption of the chip
  const CELL_V = 3.85; // Battery cell voltage

  /** Clamps a value between a minimum and maximum. */
  function clamp(x,a,b){ return Math.max(a, Math.min(b, x)); }
  /** Converts mAh to Wh. */
  function mAhToWh(mAh){ return (mAh/1000) * CELL_V; }
  /** Formats a number for display. */
  function fmt(num, digits=2){ if(isNaN(num)) return '--'; return Number(num).toLocaleString(undefined, {maximumFractionDigits: digits}); }
  /** Calculates performance factor based on process node. */
  function nodePerfFactor(nm){ return Math.pow(REF_NODE / Math.max(3, nm), 0.75); }
  /** Calculates power factor based on process node. */
  function nodePowerFactor(nm){ return Math.pow(Math.max(3, nm) / REF_NODE, 1.35); }

  /**
   * Calculates algorithm efficiency based on simulated vs. theoretical FLOPs.
   * @param {number} simulatedFlops - FLOPs measured during simulation.
   * @param {number} theoreticalFlops - Ideal theoretical FLOPs.
   * @returns {number} Efficiency (0.1 to 1.0).
   */
  function algorithmEfficiency(simulatedFlops, theoreticalFlops){
      if (theoreticalFlops <= 0) return 0;
      const efficiency = clamp(theoreticalFlops / simulatedFlops, 0.1, 1.0);
      return efficiency;
  }

  /**
   * Estimates chip temperature based on power, cooling, and process node.
   * @param {number} powerW - Total power consumption in watts.
   * @param {number} coolingW - Cooling budget in watts.
   * @param {number} nodeNm - Process node in nm.
   * @param {number} [shaderPower=0] - Power consumed by shader units.
   * @returns {number} Estimated temperature in Celsius.
   */
  function estimateThermals(powerW, coolingW, nodeNm, shaderPower = 0) {
    const baseTemp = 30 + (nodeNm - 3) * 1.5;
    const effectiveCooling = coolingW * 1.2;
    const heatGenerated = (powerW + shaderPower) * 3.5;
    let temp = baseTemp + (heatGenerated - effectiveCooling);

    if (powerW > 15) {
      temp += (powerW - 15) * 2;
    }
    return clamp(temp, 30, 150);
  }

  /**
   * Calculates throttle factor based on temperature and an optional limit.
   * @param {number} tempC - Current temperature in Celsius.
   * @param {boolean} disableThrottling - If throttling is disabled.
   * @param {number} [limit=85] - The thermal limit in Celsius above which throttling occurs.
   * @returns {number} Throttle factor (0.0 to 1.0).
   */
  function throttleFactor(tempC, disableThrottling, limit = 85){
    if (disableThrottling) return 1.0;
    if(tempC <= limit) return 1.0;
    const excess = tempC - limit;
    if(excess <= 15) return 1 - excess * 0.03; // 3% reduction per degree for first 15 degrees over limit
    return 1 - (0.45 + (excess - 15) * 0.05); // Faster reduction after that
  }

  /**
   * Returns quantization multipliers for TOPS and GFLOPS.
   * @param {string} mode - Quantization mode (int8, fp16, fp32).
   * @returns {object} Object with tops and gflops multipliers.
   */
  function quantMultipliers(mode){
    switch(mode){
      case 'int8': return {tops:1.6, gflops:0.95};
      case 'fp16': return {tops:1.0, gflops:1.0};
      case 'fp32': return {tops:0.7, gflops:0.9};
      default: return {tops:1.0, gflops:1.0};
    }
  }

  /**
   * Applies Dynamic Voltage and Frequency Scaling (DVFS) based on temperature and cap.
   * @param {object} cfg - Current chip configuration.
   * @param {number} dvfsCapMHz - DVFS clock cap in MHz.
   * @param {number} tempC - Current temperature in Celsius.
   * @param {boolean} disableThrottling - If throttling is disabled.
   * @returns {object} Object with effective core clock speeds in GHz.
   */
  function applyDVFS(cfg, dvfsCapMHz, tempC, disableThrottling){
    const tempPenalty = disableThrottling ? 1.0 : (tempC > 70 ? (1 - clamp((tempC - 70) / 30, 0, 0.4)) : 1.0);
    let perfMHz = clamp(cfg.clkPerf*1000, 200, dvfsCapMHz)*tempPenalty;
    let effMHz = clamp(cfg.clkEff*1000, 200, dvfsCapMHz)*tempPenalty;
    let hyperMHz = clamp(cfg.clkHyper*1000, 200, dvfsCapMHz)*tempPenalty;
    let npuMHz = clamp(cfg.clkNPU*1000, 100, dvfsCapMHz)*tempPenalty;

    perfMHz = Math.max(perfMHz, 200);
    effMHz = Math.max(effMHz, 200);
    hyperMHz = Math.max(hyperMHz, 200);
    npuMHz = Math.max(npuMHz, 100);

    return {
      perfGHz: perfMHz/1000,
      effGHz: effMHz/1000,
      hyperGHz: hyperMHz/1000,
      npuGHz: npuMHz/1000
    };
  }

  /**
   * Reads all input values from the UI and returns them as a configuration object.
   * @returns {object} The current chip configuration.
   */
  function readInputs() {
    const getElementValue = (id, fallback) => {
        const el = $(id);
        if (el) {
            if (el.type === 'checkbox') return el.checked;
            if (el.type === 'number' || el.type === 'range') {
              const val = parseFloat(el.value);
              return isNaN(val) ? fallback : val;
            }
            return el.value || fallback;
        }
        return fallback;
    };

    return {
      numPerf: clamp(parseInt(getElementValue('numPerf', 3)), 0, 256),
      numEff: clamp(parseInt(getElementValue('numEff', 4)), 0, 256),
      numAI: clamp(parseInt(getElementValue('numAI', 2)), 0, 256),
      numHyper: clamp(parseInt(getElementValue('numHyper', 1)), 0, 256),
      numGPU: clamp(parseInt(getElementValue('numGPU', 8)), 0, 8192),
      clkPerf: clamp(parseFloat(getElementValue('clkPerf', 3.0)), 0.4, 10),
      clkEff: clamp(parseFloat(getElementValue('clkEff', 2.0)), 0.4, 10),
      clkHyper: clamp(parseFloat(getElementValue('clkHyper', 2.5)), 0.4, 10),
      clkNPU: clamp(parseFloat(getElementValue('clkNPU', 1.4)), 0.2, 10),
      clkGPU: clamp(parseFloat(getElementValue('clkGPU', 1.5)), 0.2, 3.0),
      numShaders: clamp(parseInt(getElementValue('numShaders', 4)), 0, 512),
      shaderComplexity: getElementValue('shaderComplexity', 'medium'),
      nodeNm: clamp(parseInt(getElementValue('nodeNm', 4)), 3, 14),
      sysMem: clamp(parseInt(getElementValue('sysMem', 8192)), 128, 262144),
      battmAh: clamp(parseInt(getElementValue('battmAh', 5000)), 300, 20000),
      coolingW: clamp(parseFloat(getElementValue('coolingW', 7.5)), 0.5, 50),
      matN: clamp(parseInt(getElementValue('matN', 256)), 8, 1024),
      layers: clamp(parseInt(getElementValue('layers', 6)), 1, 64),
      thermalLimit: getElementValue('thermalLimit', NaN), // Read new thermal limit input
      dvfsCapMHz: clamp(parseFloat(getElementValue('dvfsCap', 4200)), 300, 6000),
      quantMode: getElementValue('quantMode', 'fp16'),
      weightFormat: getElementValue('weightFormat', 'fp16'),
      disableThrottling: getElementValue('disableThrottling', false),
      workloadProfile: getElementValue('workloadProfile', 'mixed'),
      algorithmJson: $('algorithmEditor').value // Get JSON string from textarea
    };
  }

  /**
   * Applies a given configuration object to update the UI elements.
   * @param {object} cfg - The configuration object to apply.
   */
  function applyConfigToUI(cfg){
    const setValue = (id, val) => {
      const el = $(id);
      if (el) {
        if (el.type === 'checkbox') el.checked = val;
        else el.value = val;
      }
    };
    const setInnerText = (id, val) => {
      const el = $(id);
      if (el) el.innerText = val;
    };

    setValue('numPerf', cfg.numPerf);
    setValue('numEff', cfg.numEff);
    setValue('numAI', cfg.numAI);
    setValue('numHyper', cfg.numHyper);
    setValue('numGPU', cfg.numGPU);
    setValue('clkPerf', cfg.clkPerf);
    setValue('clkEff', cfg.clkEff);
    setValue('clkHyper', cfg.clkHyper);
    setValue('clkNPU', cfg.clkNPU);
    setValue('clkGPU', cfg.clkGPU);
    setValue('nodeNm', cfg.nodeNm);
    setValue('sysMem', cfg.sysMem);
    setValue('battmAh', cfg.battmAh);
    setValue('coolingW', cfg.coolingW);
    setValue('matN', cfg.matN);
    setValue('layers', cfg.layers);
    // Set thermalLimit, but only if it's a valid number. Otherwise, it should remain empty/placeholder.
    const thermalLimitEl = $('thermalLimit');
    if (thermalLimitEl) {
        if (!isNaN(cfg.thermalLimit)) {
            thermalLimitEl.value = cfg.thermalLimit;
        } else {
            thermalLimitEl.value = ''; // Ensure it's cleared if NaN
        }
    }
    setValue('dvfsCap', cfg.dvfsCapMHz || 4200);
    setInnerText('dvfsVal', (cfg.dvfsCapMHz || 4200) + ' MHz');
    setValue('quantMode', cfg.quantMode || 'fp16');
    setValue('weightFormat', cfg.weightFormat || 'fp16');
    setValue('disableThrottling', cfg.disableThrottling || false);
    setValue('workloadProfile', cfg.workloadProfile || 'mixed');
    
    // Set algorithm JSON
    const algorithmEditorEl = $('algorithmEditor');
    if (algorithmEditorEl) {
        algorithmEditorEl.value = cfg.algorithmJson || DEFAULT_ALGORITHM_JSON;
    }
    updateNodePerfMeter(cfg.nodeNm);
  }

  /**
   * Updates the visual performance meter for the process node.
   * @param {number} nodeNm - Process node in nm.
   */
  function updateNodePerfMeter(nodeNm) {
    const nodePerfMeter = $('nodePerfMeter');
    if (nodePerfMeter) {
        const perf = (1 - (nodeNm - 3) / 7) * 100;
        nodePerfMeter.style.width = Math.max(10, Math.min(100, perf)) + '%';
    }
  }

  /**
   * Compares the current chip configuration with a saved configuration and shows differences.
   * @param {object} savedCfg - The saved configuration object.
   * @param {string} name - The name of the saved chip.
   */
  async function compareWithCurrent(savedCfg, name){
    const cur = readInputs();
    const diffs = [];
    const keys = ['numPerf','numEff','numAI','numHyper','numGPU','clkPerf','clkEff','clkHyper','clkNPU','clkGPU','nodeNm','battmAh','sysMem','coolingW','matN','layers','dvfsCapMHz','quantMode','weightFormat','disableThrottling','workloadProfile', 'thermalLimit'];
    for(const k of keys){
      if(savedCfg[k] !== cur[k]) diffs.push(`${k}: saved=${savedCfg[k]} vs current=${cur[k]}`);
    }
    // Also compare algorithm JSON
    if (savedCfg.algorithmJson !== cur.algorithmJson) {
      diffs.push(`Algorithm JSON: differ`);
    }
    await showCustomAlert('Comparing current with "'+name+'":\n\n' + (diffs.length? diffs.map(d => `- ${d}`).join('\n') : 'No differences found.'), 'Comparison Results');
  }

  /**
   * Packs the current UI input values into a configuration object.
   * @returns {object} The current chip configuration.
   */
  function packConfig(){
    const cfg = readInputs();
    return cfg;
  }

  /**
   * Sets the content of the algorithm editor textarea.
   * @param {string} jsonString - The JSON string to set.
   */
  function setAlgorithmJson(jsonString) {
    const algorithmEditorEl = $('algorithmEditor');
    if (algorithmEditorEl) {
        algorithmEditorEl.value = jsonString;
    }
  }

  /**
   * Beautifies a JSON string by parsing and re-stringifying it with indentation.
   * @param {string} jsonString - The JSON string to beautify.
   * @returns {string} The beautified JSON string, or original if invalid.
   */
  function beautifyJson(jsonString) {
    try {
      const obj = JSON.parse(jsonString);
      return JSON.stringify(obj, null, 2);
    } catch (e) {
      showCustomAlert('Invalid JSON. Cannot beautify: ' + e.message, 'JSON Error');
      return jsonString; // Return original if invalid
    }
  }

  // --- Local Storage Functions ---
  /**
   * Saves a chip configuration to local storage.
   * @param {string} name - The name of the chip.
   * @param {object} cfg - The configuration object to save.
   * @returns {boolean} True if saved successfully, false otherwise.
   */
  function saveChip(name, cfg) {
    try {
      localStorage.setItem('chip_simulator_' + name, JSON.stringify(cfg));
      return true;
    } catch (e) {
      console.error("Error saving chip:", e);
      return false;
    }
  }

  /**
   * Loads a chip configuration from local storage.
   * @param {string} name - The name of the chip to load.
   * @returns {object|null} The loaded configuration object, or null if not found/error.
   */
  function loadChip(name) {
    try {
      const data = localStorage.getItem('chip_simulator_' + name);
      return data ? JSON.parse(data) : null;
    } catch (e) {
      console.error("Error loading chip:", e);
      return null;
    }
  }

  /**
   * Lists all saved chip names from local storage.
   * @returns {string[]} An array of saved chip names.
   */
  function listSavedChips() {
    const names = [];
    for (let i = 0; i < localStorage.length; i++) {
      const key = localStorage.key(i);
      if (key && key.startsWith('chip_simulator_')) {
        names.push(key.substring('chip_simulator_'.length));
      }
    }
    return names;
  }

  /**
   * Deletes a chip configuration from local storage.
   * @param {string} name - The name of the chip to delete.
   * @returns {boolean} True if deleted successfully, false otherwise.
   */
  function deleteChip(name) {
    try {
      localStorage.removeItem('chip_simulator_' + name);
      return true;
    }
    catch (e) {
      console.error("Error deleting chip:", e);
      return false;
    }
  }

  /**
   * Clears all saved chips from local storage after confirmation.
   */
  async function clearSaved() {
    await showCustomConfirm('Are you sure you want to clear all saved chips? This cannot be undone.', 'Clear All Saved Chips',
      () => {
        for (let i = localStorage.length - 1; i >= 0; i--) {
          const key = localStorage.key(i);
          if (key && key.startsWith('chip_simulator_')) {
            localStorage.removeItem(key);
          }
        }
        renderSavedList();
        showCustomAlert('All saved chips cleared!', 'Cleared');
      }
    );
  }

  /** Renders the list of saved chips in the UI. */
  function renderSavedList() {
    const savedListEl = $('savedList');
    if (!savedListEl) return;
    const chips = listSavedChips();
    if (chips.length === 0) {
      savedListEl.innerHTML = '<div class="small help text-center py-4">No saved chips yet. Save one!</div>';
      return;
    }
    savedListEl.innerHTML = chips.map(name => `
      <div class="chip-list-item mb-2">
        <span class="text-white flex-grow">${name}</span>
        <button class="btn btn-ghost small" data-action="load" data-name="${name}">Load</button>
        <button class="btn btn-ghost small text-red-400" data-action="delete" data-name="${name}">Delete</button>
      </div>
    `).join('');

    savedListEl.querySelectorAll('button[data-action="load"]').forEach(button => {
      button.onclick = async (e) => {
        const name = e.target.dataset.name;
        const cfg = loadChip(name);
        if (cfg) {
          applyConfigToUI(cfg);
          const chipTagEl = $('chipTag');
          if (chipTagEl) chipTagEl.innerText = name;
          await showCustomAlert('Loaded chip: ' + name, 'Success');
          runSimulation().catch(console.error);
        } else {
          showCustomAlert('Failed to load chip: ' + name, 'Error');
        }
      };
    });

    savedListEl.querySelectorAll('button[data-action="delete"]').forEach(button => {
      button.onclick = async (e) => {
        const name = e.target.dataset.name;
        await showCustomConfirm('Delete chip: ' + name + '?', 'Confirm Delete',
          () => {
            if (deleteChip(name)) {
              showCustomAlert('Deleted chip: ' + name, 'Success');
              renderSavedList();
            } else {
              showCustomAlert('Failed to delete chip: ' + name, 'Error');
            }
          }
        );
      };
    });
  }
  // --- End Local Storage Functions ---

  /**
   * Helper function to set the inner text content of an element.
   * @param {string} id - The ID of the element.
   * @param {string} value - The text value to set.
   */
  function setText(id, value) {
    const el = $(id);
    if (el) {
        el.innerText = value;
    }
  }

  const shaderComplexityMultiplier = {
        low: 0.01,
        medium: 0.02,
        high: 0.03
      };

  /**
   * Calculates an estimated price for the chip based on its configuration.
   * This is a simplified, fictional pricing model.
   * @param {object} cfg - The chip configuration.
   * @returns {number} Estimated price in dollars.
   */
  function calculatePrice(cfg) {
    let price = 5; // Base price

    const PRICE_SCALING_FACTOR = 0.7;

    // Core costs
    price += cfg.numPerf * 0.5;
    price += cfg.numEff * 0.5;
    price += cfg.numAI * 0.5;
    price += cfg.numHyper * 1;
    price += cfg.numGPU * 1;

    // Clock speed costs
    price += (cfg.clkPerf - 0.4) * 0.5 * cfg.numPerf;
    price += (cfg.clkEff - 0.4) * 0.5 * cfg.numEff;
    price += (cfg.clkHyper - 0.4) * 0.5 * cfg.numHyper;
    price += (cfg.clkNPU - 0.3) * 1 * cfg.numAI;
    price += (cfg.clkGPU - 0.5) * 0.7 * cfg.numGPU;

    // Shader costs
    const complexityFactor = shaderComplexityMultiplier[cfg.shaderComplexity] || 1.0;
    price += cfg.numShaders * 0.01 * complexityFactor;

    // Process node cost (smaller nodes are exponentially more expensive)
    price += Math.pow((7 - cfg.nodeNm), 2) * 7;

    // System memory cost
    price += (cfg.sysMem / 1024) * 1;

    // Cooling budget cost
    price += cfg.coolingW * 5;

    // Battery capacity cost
    price += (cfg.battmAh / 1000) * 0;

    // Quantization mode cost
    if (cfg.quantMode === 'int8') price += 2;
    if (cfg.quantMode === 'fp32') price += 1;

    // Algorithm complexity cost (simplified)
    price += (cfg.layers * cfg.matN / 1000) * 0.1;

    return Math.max(10, price * PRICE_SCALING_FACTOR); // Minimum price
  }

  /** Initializes or updates the Chart.js instance for Performance/Watt chart. */
  function initChart() {
    const ctx = $('ppwChart');
    if (!ctx) return;

    const chartType = chartIsLog ? 'logarithmic' : 'linear';

    // Destroy existing chart to prevent memory leaks and re-render with new options
    if (ppwChart) {
      ppwChart.destroy();
    }

    ppwChart = new Chart(ctx, {
      type: 'bar',
      data: {
        labels: ['Light Use', 'Mixed Use', 'Heavy Use'],
        datasets: [{
          label: 'Composite Score per Watt',
          data: lastChartData,
          backgroundColor: [
            'rgba(75, 192, 192, 0.6)', // Light Use
            'rgba(153, 102, 255, 0.6)', // Mixed Use
            'rgba(255, 159, 64, 0.6)'  // Heavy Use
          ],
          borderColor: [
            'rgba(75, 192, 192, 1)',
            'rgba(153, 102, 255, 1)',
            'rgba(255, 159, 64, 1)'
          ],
          borderWidth: 1,
          borderRadius: 6
        }]
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        scales: {
          y: {
            type: chartType,
            beginAtZero: true,
            title: {
              display: true,
              text: 'Composite Score / Watt (Higher is Better)',
              color: '#dbeafe'
            },
            ticks: { color: '#9fb0c6' },
            grid: { color: 'rgba(255,255,255,0.08)' }
          },
          x: {
            ticks: { color: '#9fb0c6' },
            grid: { display: false }
          }
        },
        plugins: {
          legend: {
            display: false, // Hide legend for single dataset
          },
          tooltip: {
            callbacks: {
              label: function(context) {
                return `${context.dataset.label}: ${context.raw.toFixed(2)}`;
              }
            }
          }
        }
      }
    });
  }

  /**
   * Evaluates chart data and generates descriptive messages.
   * @param {number[]} values - Array of performance-per-watt values for different workloads.
   * @returns {string[]} An array of descriptive strings.
   */
  function evaluateChartData(values) {
    const [light, mixed, heavy] = values;
    const descriptions = [];

    if (light > 50000) {
      descriptions.push('✅ Excellent efficiency during light use; great for everyday browsing and standby.');
    } else if (light > 20000) {
      descriptions.push('👍 Good efficiency for light tasks; performs well without draining battery excessively.');
    } else {
      descriptions.push('⚠️ Moderate efficiency for light use; could be improved for better battery life during idle tasks.');
    }

    if (mixed > 40000) {
      descriptions.push('✅ Strong performance per watt in mixed scenarios; handles diverse tasks efficiently.');
    } else if (mixed > 15000) {
      descriptions.push('👍 Decent mixed-use efficiency; capable for daily apps and moderate multitasking.');
    } else {
      descriptions.push('⚠️ Lower efficiency in mixed use; may consume more power during typical daily activities.');
    }

    if (heavy > 30000) {
      descriptions.push('✅ Outstanding sustained performance per watt under heavy load; ideal for gaming and intense applications.');
    } else if (heavy > 10000) {
      descriptions.push('👍 Solid heavy-use efficiency; maintains good performance during demanding tasks.');
    } else {
      descriptions.push('⚠️ Sub-optimal heavy-use efficiency; consider reviewing cooling or core configuration for demanding applications.');
    }

    // Overall verdicts
    if (Math.max(...values) < 5000) {
        descriptions.push('🚨 Overall very low performance per watt. Chip design may be highly inefficient or underpowered.');
    } else if (Math.min(...values) > 70000) {
        descriptions.push('🚀 Exceptional performance per watt across all workloads. A truly efficient design!');
    }

    return descriptions;
  }

  // --- Run Architecture Function, driven by JSON config ---
  /**
   * Runs the simulated algorithm based on the provided JSON configuration.
   * This function calculates deterministic metrics rather than real-world timing.
   * @param {number} layers - Number of neural network layers.
   * @param {number} N - Matrix size (N x N).
   * @param {object} algorithmConfig - Parsed JSON object defining the algorithm.
   * @returns {Promise<object>} An object containing simulation results (ms, flops, iops, peakBytes, architecturalHints).
   * @throws {Error} If there's an error in the algorithm configuration or execution.
   */
  async function runArchitectureWithJson(layers, N, algorithmConfig) {
    const metrics = { flops: 0, iops: 0, peakBytes: 0 };
    let X = createMatrix(N,N, metrics); // Initial input matrix
    let currentOptimalBlockSize = 0; // To track if a blocked method is used

    for(let L=0; L<layers; L++){
      let Y = X; // For residual connections, Y stores the input before processing for this layer
      // Iterate and execute each operation in the sequence
      for (let i = 0; i < algorithmConfig.sequence.length; i++) {
        const op = algorithmConfig.sequence[i];
        try {
          if (op.type === "matrixMultiply") {
            const W = createMatrix(N, N, metrics); // Create a weight matrix for multiplication
            if (op.method === "naive") {
              X = multiplyMatricesNaive(X, W, metrics);
            } else if (op.method === "blocked") {
              const blockSize = typeof op.blockSize === 'number' && op.blockSize > 0 ? op.blockSize : 32;
              X = multiplyMatricesBlocked(X, W, metrics, blockSize);
              currentOptimalBlockSize = Math.max(currentOptimalBlockSize, blockSize);
            } else {
              throw new Error(`Unknown matrix multiply method: '${op.method}'. Supported: 'naive', 'blocked'.`);
            }
          } else if (op.type === "activation") {
            if (op.function === "relu") {
              X = applyActivationRelu(X, metrics);
            } else if (op.function === "sigmoid") {
              X = applyActivationSigmoid(X, metrics);
            } else if (op.function === "tanh") {
              X = applyActivationTanh(X, metrics);
            }
            else {
              throw new Error(`Unknown activation function: '${op.function}'. Supported: 'relu', 'sigmoid', 'tanh'.`);
            }
          } else if (op.type === "conditionalResidual") {
            // Apply residual only if enabled and current layer matches frequency
            if (op.enabled && (typeof op.frequency === 'number' && op.frequency > 0 && (L + 1) % op.frequency === 0)) { // (L+1) for 1-based layer indexing
              X = addResidual(X, Y, metrics); // Add residual connection
            }
          } else {
            throw new Error(`Unknown operation type: '${op.type}'. Supported: 'matrixMultiply', 'activation', 'conditionalResidual'.`);
          }
        } catch (opErr) {
            throw new Error(`Error in sequence operation ${i} (type: ${op.type || 'N/A'}): ${opErr.message}`);
        }
      }
      // Yield to browser to prevent UI freezing during long calculations
      if(L % 2 === 0) await new Promise(r=>setTimeout(r,0));
    }

    // Determine optimalDataBlockSizeKB based on user hint or inferred value
    let finalOptimalBlockSizeKB = 0;
    if (algorithmConfig.architecturalHints && typeof algorithmConfig.architecturalHints.optimalDataBlockSizeKB === 'number') {
        finalOptimalBlockSizeKB = algorithmConfig.architecturalHints.optimalDataBlockSizeKB;
    } else if (currentOptimalBlockSize > 0) {
        // If blocked method was used but no explicit hint, infer from the largest block size
        finalOptimalBlockSizeKB = Math.ceil((currentOptimalBlockSize * currentOptimalBlockSize * 8) / 1024);
    } else {
        // Fallback to full matrix size as a hint if no specific block hint and not explicitly set by user
        finalOptimalBlockSizeKB = Math.ceil((N * N * 8) / 1024);
    }

    // Calculate a deterministic 'ms' based on total FLOPs
    // Calibrated so that the default algorithm (256x256, 6 layers, naive) results in approx. 100ms.
    const FLOP_RATE_MPS_CALIBRATED = 21100000; // ~21.1 million FLOPs per millisecond
    const deterministicMs = metrics.flops / FLOP_RATE_MPS_CALIBRATED;

    return {
      ms: deterministicMs, // Now always deterministic
      flops: metrics.flops,
      iops: metrics.iops,
      peakBytes: metrics.peakBytes,
      architecturalHints: {
        optimalDataBlockSizeKB: finalOptimalBlockSizeKB,
      }
    };
  }

  // --- JSON Schema Validation for Algorithm Configuration ---
  /**
   * Validates the structure and content of the algorithm JSON configuration.
   * @param {object} config - The parsed algorithm configuration object.
   * @param {number} N - The matrix size (N) for semantic checks.
   * @returns {string[]} An array of error messages. Empty if valid.
   */
  function validateAlgorithmConfig(config, N) {
    const errors = [];

    if (typeof config.layers !== 'number' || config.layers <= 0) {
      errors.push("Top-level property 'layers' must be a positive number.");
    }
    if (!Array.isArray(config.sequence)) {
      errors.push("Top-level property 'sequence' must be an array.");
    } else {
      if (config.sequence.length === 0) {
          errors.push("The 'sequence' array cannot be empty. Define at least one operation.");
      }
      for (let i = 0; i < config.sequence.length; i++) {
        const op = config.sequence[i];
        if (typeof op !== 'object' || op === null) {
          errors.push(`Sequence item ${i}: must be an object.`);
          continue; // Skip further validation for this op if type is missing
        }

        if (typeof op.type !== 'string') {
          errors.push(`Sequence item ${i}: 'type' property is missing or not a string.`);
          continue;
        }

        switch (op.type) {
          case 'matrixMultiply':
            if (op.method !== 'naive' && op.method !== 'blocked') {
              errors.push(`Sequence item ${i} (matrixMultiply): 'method' must be 'naive' or 'blocked'. Found: '${op.method}'`);
            }
            if (op.method === 'blocked' && typeof op.blockSize !== 'number') {
              errors.push(`Sequence item ${i} (matrixMultiply, blocked): 'blockSize' must be a number.`);
            } else if (op.method === 'blocked' && typeof op.blockSize === 'number') {
              if (op.blockSize <= 0) {
                errors.push(`Sequence item ${i} (matrixMultiply, blocked): 'blockSize' must be a positive number.`);
              }
              if (op.blockSize > N) {
                errors.push(`Sequence item ${i} (matrixMultiply, blocked): 'blockSize' (${op.blockSize}) cannot be larger than the matrix size N (${N}).`);
              }
              // Check if it's a power of 2, which is common for block sizes.
              if ((op.blockSize & (op.blockSize - 1)) !== 0) {
                errors.push(`Sequence item ${i} (matrixMultiply, blocked): 'blockSize' (${op.blockSize}) is not a power of two. This is recommended for performance.`);
              }
            }
            break;
          case 'activation':
            if (op.function !== 'relu' && op.function !== 'sigmoid' && op.function !== 'tanh') {
              errors.push(`Sequence item ${i} (activation): 'function' must be 'relu', 'sigmoid', or 'tanh'. Found: '${op.function}'`);
            }
            break;
          case 'conditionalResidual':
            if (typeof op.enabled !== 'boolean') {
              errors.push(`Sequence item ${i} (conditionalResidual): 'enabled' must be a boolean (true/false).`);
            }
            if (typeof op.frequency !== 'number' || op.frequency <= 0) {
              errors.push(`Sequence item ${i} (conditionalResidual): 'frequency' must be a positive number.`);
            }
            break;
          default:
            errors.push(`Sequence item ${i}: Unknown operation type '${op.type}'. Supported types: 'matrixMultiply', 'activation', 'conditionalResidual'.`);
        }
      }
    }

    if (config.architecturalHints && config.architecturalHints.optimalDataBlockSizeKB !== undefined) {
      const hint = config.architecturalHints.optimalDataBlockSizeKB;
      if (typeof hint !== 'number' && hint !== 'auto') {
        errors.push("architecturalHints.optimalDataBlockSizeKB must be a number or the string 'auto'.");
      }
      if (typeof hint === 'number' && hint < 0) {
          errors.push("architecturalHints.optimalDataBlockSizeKB (if number) must be non-negative.");
      }
    }

    return errors;
  }

  /**
   * Main function to run the chip simulation.
   * Fetches inputs, performs calculations, updates UI, and handles errors.
   */
  async function runSimulation(){
    const loadingOverlay = $('loadingOverlay');
    const progressText = $('progressText');
    if (loadingOverlay) loadingOverlay.style.display = 'flex'; // Show loading overlay
    if (progressText) progressText.innerText = 'Initializing...';
    
    document.body.classList.remove('thermal-critical'); // Remove thermal warning animation
    await new Promise(r=>setTimeout(r,20)); // Allow UI to update

    try {
      const cfg = readInputs(); // Get current configuration from UI

      // --- Pre-simulation Hardware Parameter Validation & Warnings ---
      const warnings = [];
      if(cfg.numPerf + cfg.numEff + cfg.numHyper + cfg.numAI + cfg.numGPU <= 0)
        warnings.push('At least one core type is required for simulation.');
      if(cfg.clkPerf > 5) warnings.push('Performance Core clock is above typical max (5 GHz), results may be unrealistic.');
      if(cfg.clkEff > 3) warnings.push('Efficiency Core clock is above typical max (3 GHz), results may be unrealistic.');
      if(cfg.clkHyper > 4) warnings.push('Hyper Core clock is above typical max (4 GHz), results may be unrealistic.');
      if(cfg.clkNPU > 3) warnings.push('NPU clock is above typical max (3 GHz), results may be unrealistic.');
      if(cfg.clkGPU > 2.5) warnings.push('GPU clock is above typical max (2.5 GHz), results may be unrealistic.');
      if(cfg.nodeNm < 3 || cfg.nodeNm > 14) warnings.push('Process node should be between 3 and 14 nm for realistic simulation.');
      if(cfg.matN < 16 || cfg.matN > 1024)
        warnings.push('Matrix size must be between 16 and 1024. Current: ' + cfg.matN);
      if(cfg.layers < 1 || cfg.layers > 64)
        warnings.push('NN Layers must be between 1 and 64. Current: ' + cfg.layers);

      if (warnings.length > 0) {
          await showCustomAlert('Hardware Configuration Warnings:\n\n' + warnings.map(w => `- ${w}`).join('\n'), 'Configuration Warning');
      }
      // --- End Pre-simulation Hardware Parameter Validation ---

      let archResult = null;
      let algorithmConfigParsed;
      try {
        if (progressText) progressText.innerText = 'Parsing algorithm JSON...';
        algorithmConfigParsed = JSON.parse(cfg.algorithmJson);

        // --- Algorithm JSON Schema Validation (before execution) ---
        const algorithmValidationErrors = validateAlgorithmConfig(algorithmConfigParsed, cfg.matN);
        if (algorithmValidationErrors.length > 0) {
            throw new Error("Invalid Algorithm JSON:\n" + algorithmValidationErrors.map(e => `- ${e}`).join('\n'));
        }
        // --- End Algorithm JSON Schema Validation ---

        if (progressText) progressText.innerText = 'Evaluating algorithm...';
        archResult = await runArchitectureWithJson(cfg.layers, cfg.matN, algorithmConfigParsed);

      } catch(err) {
        // Display algorithm-specific errors
        await showCustomAlert('Algorithm Configuration Error:\n' + (err.message || err), 'Algorithm Error');
        console.error("Detailed Algorithm Error:", err);
        if (loadingOverlay) loadingOverlay.style.display = 'none'; // Hide loading overlay on error
        return; // Stop simulation on algorithm error
      }

      if (progressText) progressText.innerText = 'Computing performance metrics...';
      await new Promise(r=>setTimeout(r,50)); // Allow UI to update

      // Apply process node factors
      const perfF = nodePerfFactor(cfg.nodeNm); // Performance scaling due to node size
      const powF = nodePowerFactor(cfg.nodeNm); // Power scaling due to node size

      // R0 Metrics (Raw Algorithm Performance)
      const r0_ms = archResult.ms;
      const r0_flops = archResult.flops;
      const r0_peakBytes = archResult.peakBytes;

      // Algorithm Efficiency calculation
      const theoreticalMathFlopsIdeal = cfg.layers * 2 * Math.pow(cfg.matN, 3); // Simplified theoretical max FLOPs
      const algEff = algorithmEfficiency(r0_flops, theoreticalMathFlopsIdeal);

      // Architectural Alignment calculation and advice
      let archAlignmentFactor = 1.0;
      let archAlignmentAdvice = '';
      const optimalDataBlockSizeKB = archResult.architecturalHints.optimalDataBlockSizeKB;
      const systemCacheEquivalentKB = cfg.sysMem; // Simplified, treating all sysMem as cache for this metric

      if (typeof optimalDataBlockSizeKB === 'number' && optimalDataBlockSizeKB >= 0 && systemCacheEquivalentKB) {
          if (optimalDataBlockSizeKB === 0) {
              archAlignmentAdvice = `<span class="success">Good Alignment:</span> Algorithm has minimal data block needs or is not sensitive to block size.`;
              archAlignmentFactor = 1.0;
          } else if (optimalDataBlockSizeKB < (systemCacheEquivalentKB * 0.1)) { // If block size is very small relative to memory
              archAlignmentAdvice = `<span class="success">Excellent Alignment:</span> Your algorithm's data blocks (${optimalDataBlockSizeKB.toFixed(0)}KB) fit perfectly within system memory/cache (${systemCacheEquivalentKB}KB).`;
              archAlignmentFactor = 1.05; // Small bonus for excellent fit
          } else if (optimalDataBlockSizeKB > systemCacheEquivalentKB) { // If block size exceeds memory
              archAlignmentAdvice = `<span class="warning">Low Alignment:</span> Your algorithm's data block needs (${optimalDataBlockSizeKB.toFixed(0)}KB) exceed available memory (${systemCacheEquivalentKB}KB). Significant performance loss due to cache misses.`;
              archAlignmentFactor = clamp(systemCacheEquivalentKB / optimalDataBlockSizeKB, 0.2, 1.0); // More severe penalty
          } else { // Good fit
              archAlignmentAdvice = `<span class="success">Good Alignment:</span> Your algorithm's data blocks (${optimalDataBlockSizeKB.toFixed(0)}KB) align well with system memory (${systemCacheEquivalentKB}KB).`;
              archAlignmentFactor = 1.0;
          }
      } else {
          archAlignmentAdvice = `<span class="help">Alignment data unavailable:</span> No specific optimal block size hint from algorithm.`;
          archAlignmentFactor = 1.0; // Neutral if no hint
      }

      // R1 Metrics (Theoretical Hardware Potential)
      let r1_theoGF = (
        cfg.numPerf * PERF_GFLOPS_PER_GHZ * cfg.clkPerf +
        cfg.numEff  * EFF_GFLOPS_PER_GHZ * cfg.clkEff +
        cfg.numHyper* HYPER_GFLOPS_PER_GHZ * cfg.clkHyper
      ) * perfF;
      let r1_theoTOPS = (cfg.numAI * AI_TOPS_PER_GHZ * cfg.clkNPU) * perfF;
      let r1_theoGPU = cfg.numGPU * GPU_TFLOPS_PER_CORE_BASE * cfg.clkGPU * perfF;

      // Apply quantization multipliers
      const qm = quantMultipliers(cfg.quantMode);
      r1_theoTOPS *= qm.tops;
      r1_theoGF *= qm.gflops;

      // Workload profile multipliers for performance and power
      let perfMultiplier = 1.0;
      let powerMultiplier = 1.0;
      let basePowerAdjustment = 0;

      switch (cfg.workloadProfile) {
          case 'gaming':
              perfMultiplier = 1.0;
              powerMultiplier = 1.8;
              basePowerAdjustment = 2.0;
              break;
          case 'videoEditing':
              perfMultiplier = 1.1;
              powerMultiplier = 1.5;
              basePowerAdjustment = 1.5;
              break;
          case 'socialMedia':
              perfMultiplier = 0.5;
              powerMultiplier = 0.6;
              basePowerAdjustment = 0.5;
              break;
          case 'idle':
              perfMultiplier = 0.1;
              powerMultiplier = 0.1;
              basePowerAdjustment = 0.1;
              break;
          case 'mixed':
          default:
              break;
      }

      // Initial peak power estimation
      let peakW = (
        cfg.numPerf * POW_PERF_W * (cfg.clkPerf / 3.0) + // Scaled by clock relative to default
        cfg.numEff  * POW_EFF_W * (cfg.clkEff / 2.0) +
        cfg.numHyper* POW_HYPER_W * (cfg.clkHyper / 2.5) +
        cfg.numAI  * POW_AI_W * (cfg.clkNPU / 1.5) +
        cfg.numGPU * POW_GPU_W_PER_GHZ * cfg.clkGPU
      );
      peakW = (peakW * powF + BASE_PEAK_W) * powerMultiplier + basePowerAdjustment;

      // Shader power calculation based on units and complexity
      let shaderPower = cfg.numShaders * POW_SHADER_W_PER_UNIT * cfg.clkGPU;
      switch(cfg.shaderComplexity){
        case 'low': shaderPower *= 0.8; break;
        case 'medium': shaderPower *= 1.0; break;
        case 'high': shaderPower *= 1.3; break;
      }

      if (cfg.workloadProfile === 'idle') {
        shaderPower *= 0.2; // Only 20% active
      }
      
      // New: Calculate peakW_post first (before tPost as per user instructions)
      // New, more realistic power calculation based on efficiency penalties
      // Inefficient algorithms and poor memory alignment increase power draw due to wasted work and data movement.
      const powerPenaltyFactor = (1 + (1 - algEff) * 0.5 + (1 - archAlignmentFactor) * 1.5);

      let dynamic_power = (
        cfg.numPerf * POW_PERF_W * (cfg.clkPerf / 3.0) + // Using cfg.clk here, DVFS applied later
        cfg.numEff  * POW_EFF_W  * (cfg.clkEff / 2.0) +
        cfg.numHyper* POW_HYPER_W* (cfg.clkHyper / 2.5) +
        cfg.numAI  * POW_AI_W * (cfg.clkNPU / 1.5) +
        cfg.numGPU * POW_GPU_W_PER_GHZ * cfg.clkGPU
      );
      if (cfg.workloadProfile === 'idle') {
          dynamic_power *= 0.3; // Only 30% of dynamic power active
      }

      // Apply the penalty factor to the dynamic power component
      dynamic_power *= powerPenaltyFactor;

      // The final power is the sum of penalized dynamic power and base power, adjusted for other factors.
      // Note: `thr` is not yet applied here because `tPost` needs to be calculated first.
      let peakW_post = (dynamic_power * powF + BASE_PEAK_W + shaderPower) * powerMultiplier + basePowerAdjustment;

      // 1. Calculate tPost first
      let tPost = estimateThermals(peakW_post, cfg.coolingW, cfg.nodeNm, shaderPower);

      // 2. Then compute thr using either default or user-defined thermal limit
      let thr = 1.0; // Initialize throttle factor
      const thermalLimit = cfg.thermalLimit; // Get value from input

      if (!isNaN(thermalLimit) && thermalLimit >= 60 && thermalLimit <= 120) {
        thr = throttleFactor(tPost, false, thermalLimit); // use custom limit
      } else {
        thr = throttleFactor(tPost, cfg.disableThrottling); // use default logic
      }
      
      // Recalculate peakW_post *with* the throttle factor now that thr is known
      peakW_post = (dynamic_power * powF + BASE_PEAK_W + shaderPower) * powerMultiplier * thr + basePowerAdjustment;


      const SHADER_GFLOPS_BASE = 0.5; // GFLOPS per shader unit at base complexity
      let shaderMultiplier = 1.0;
      switch(cfg.shaderComplexity){
        case 'low': shaderMultiplier = 0.7; break;
        case 'medium': shaderMultiplier = 1.0; break;
        case 'high': shaderMultiplier = 1.4; break;
      }
      const shaderGFLOPS = cfg.numShaders * SHADER_GFLOPS_BASE * shaderMultiplier * perfF;

      // Incorporate algorithm runtime (r0_ms) into performance
      const BASELINE_ALGORITHM_MS = 100; // A heuristic baseline for "good" algorithm runtime
      const runtimePerformanceFactor = clamp(BASELINE_ALGORITHM_MS / r0_ms, 0.1, 2.0); // Reward faster, penalize slower
      let runtimeImpactMessage = '';
      if (runtimePerformanceFactor > 1.1) {
          runtimeImpactMessage = `<span class="success">Excellent Algorithm Speed:</span> Your algorithm executes very fast, boosting overall performance.`;
      } else if (runtimePerformanceFactor < 0.9) {
          runtimeImpactMessage = `<span class="warning">Slower Algorithm Speed:</span> Your algorithm's runtime is affecting overall performance. Consider optimizing it.`;
      } else {
          runtimeImpactMessage = `Algorithm runtime has a neutral impact on overall performance.`;
      }

      // Apply DVFS (Dynamic Voltage and Frequency Scaling) - moved after thr is known
      const dvfsCapEl = $('dvfsCap');
      const dvfsCap = dvfsCapEl ? parseFloat(dvfsCapEl.value) : 4200;
      // Pass the *actual* tPost (after power recalculated with thr) to DVFS
      const dvfsApplied = applyDVFS(cfg, dvfsCap, tPost, cfg.disableThrottling);

      // R2 Metrics (Effective Real-World Performance)
      let effGF = (r1_theoGF * (dvfsApplied.perfGHz / cfg.clkPerf) + shaderGFLOPS) * algEff * thr * perfMultiplier * archAlignmentFactor * runtimePerformanceFactor;
      let effTOPS = (r1_theoTOPS * (dvfsApplied.npuGHz / cfg.clkNPU)) * algEff * thr * perfMultiplier * archAlignmentFactor * runtimePerformanceFactor;
      let effGPU = r1_theoGPU * algEff * thr * perfMultiplier * archAlignmentFactor * runtimePerformanceFactor;


      const peakMB = (r0_peakBytes || 0) / (1024*1024); // Convert bytes to MB
      const memOK = peakMB <= cfg.sysMem; // Check if peak memory usage is within system memory

      // Composite Benchmark Score
      const bench = Math.round(
        (Math.pow(effGF, 0.92) * 520) + // GFLOPS contribution
        (Math.pow(effTOPS, 0.88) * 980) + // TOPS contribution
        (Math.pow(effGPU, 0.85) * 700) // GPU TFLOPS contribution
      );

      // Battery life calculations
      const battWh = mAhToWh(cfg.battmAh);
      // Average power consumption based on workload utilization and base power
      const utilLight = 0.10, utilMixed = 0.28, utilHeavy = 0.65;
      const baseLightW = 1.1, baseMixedW = 1.6, baseHeavyW = 2.2;

      function avgPower(util, baseW, dynamicPeakW){
        const dynPart = dynamicPeakW * util;
        return baseW + Math.max(0, dynPart);
      }
      const pLight = avgPower(utilLight, baseLightW, peakW_post);
      const pMixed = avgPower(utilMixed, baseMixedW, peakW_post);
      const pHeavy = avgPower(utilHeavy, baseHeavyW, peakW_post);

      function hours(Wh, W){
        const raw = Wh / Math.max(0.9, W); // Prevent division by zero/very small numbers
        return clamp(raw, 1.8, 48); // Clamp hours to a realistic range
      }

      const hLight = hours(battWh, pLight);
      const hMixed = hours(battWh, pMixed);
      const hHeavy = hours(battWh, pHeavy);

      // Determine chip specialization based on core counts
      let specialization = [];
      const coreCounts = {perf: cfg.numPerf, eff: cfg.numEff, ai: cfg.numAI, hyper: cfg.numHyper, gpu: cfg.numGPU};
      const maxCoreCount = Math.max(...Object.values(coreCounts));

      if(cfg.numAI === maxCoreCount && cfg.numAI > 0) specialization.push('AI-optimized chip (accelerates ML tasks)');
      if(cfg.numPerf === maxCoreCount && cfg.numPerf > 0) specialization.push('Performance CPU-focused chip (gaming & heavy CPU load)');
      if(cfg.numEff === maxCoreCount && cfg.numEff > 0) specialization.push('Efficiency-optimized chip (battery friendly)');
      if(cfg.numGPU === maxCoreCount && cfg.numGPU > 0) specialization.push('GPU-heavy chip (graphics & parallel compute)');
      if(cfg.numHyper > 0) specialization.push('Includes Hyper cores (specialized compute accelerators)');
      if(specialization.length === 0) specialization.push('Balanced design'); // Fallback if no specific specialization

      // Thermal warning messages
      let thermalWarning = '';
      if(tPost >= 120) {
        thermalWarning = '<span class="warning">DANGER:</span> Device will overheat severely and likely be damaged!';
        document.body.classList.add('thermal-critical'); // Add critical thermal animation
      }
      else if(tPost >= 100)
        thermalWarning = '<span class="warning">CRITICAL:</span> Device will likely shut down under heavy load due to extreme heat.';
      else if(tPost >= 90)
        thermalWarning = '<span class="warning">WARNING:</span> High temperatures expected; significant throttling likely.';
      else if(tPost >= 80)
        thermalWarning = '<span class="warning">NOTICE:</span> Device is warm to the touch; minor throttling possible.';
      else if(tPost >= 65)
        thermalWarning = '<span class="warning">Warm:</span> Device feels noticeably warm during use.';
      else if(tPost >= 50)
        thermalWarning = '<span class="success">Normal:</span> Device is warm but comfortable.';
      else if(tPost >= 35)
        thermalWarning = '<span class="success">Cool:</span> Device runs cool to the touch.';
      else {
        thermalWarning = '<span class="success">Very Cool:</span> Device operating at optimal low temperatures.';
      }

      // Performance advice based on FLOPs/TOPS
      let flopAdvice = '';
      if(effTOPS > 3000)
        flopAdvice = '<span class="success">Excels in AI and ML workloads.</span>';
      else if(effGF > 10000)
        flopAdvice = '<span class="success">Strong general compute and floating point performance.</span>';

      // Risk assessment for unrealistic specs
      let errorRisk = '';
      let riskScore = 0;
      if(cfg.clkPerf > 5) riskScore += 2;
      if(cfg.clkEff > 3) riskScore += 1.5;
      if(cfg.clkHyper > 4) riskScore += 1.5;
      if(cfg.clkNPU > 3) riskScore += 1.5;
      if(cfg.clkGPU > 2.5) riskScore += 1.5;
      if(cfg.numPerf + cfg.numEff + cfg.numAI + cfg.numHyper + cfg.numGPU > 256) riskScore += 3;
      if(cfg.battmAh > 10000) riskScore += 1;
      if(cfg.coolingW < 2) riskScore += 2;
      if (cfg.disableThrottling && tPost > 100) riskScore += 3; // High risk if throttling disabled and critical temp

      if(riskScore >= 4)
        errorRisk = '<span class="warning">High risk of unrealistic or unstable simulation results due to extreme specs.</span>';
      else if(riskScore >= 2)
        errorRisk = '<span class="warning">Moderate risk of unrealistic behavior; check input parameters carefully.</span>';

      // Overall verdict for the chip design
      let verdict = 'Balanced device for everyday use.';
      if(bench > 2200000) verdict = 'Absolute flagship — pro-grade performance & AI.';
      else if(bench > 1400000) verdict = 'High-end performer — strong for gaming & creators.';
      else if(bench > 800000) verdict = 'Upper mid-range device.';
      else if(bench < 350000) verdict = 'Entry-level / budget profile.';

      // Update thermal and throttle bars visually
      const tempPercent = clamp((tPost - 30) / 90, 0, 1) * 100;
      const throttlePercent = (1 - thr) * 100;
      const tempBarEl = $('tempBar');
      const throttleBarEl = $('throttleBar');
      if (tempBarEl) tempBarEl.style.width = tempPercent + '%';
      if (throttleBarEl) throttleBarEl.style.width = throttlePercent + '%';

      // Update Live KPIs in the UI
      setText('k_time', fmt(r0_ms, 2) + ' ms');
      setText('k_gflops', fmt(effGF, 2));
      setText('k_tops', fmt(effTOPS, 2));
      setText('k_gpu', fmt(effGPU, 2));
      setText('k_power', fmt(peakW_post, 2));
      setText('k_temp', fmt(tPost, 1) + ' °C');
      setText('k_throttle', fmt(throttlePercent, 1) + '%');
      setText('k_bench', bench.toLocaleString());
      setText('k_batt', hMixed.toFixed(1) + ' h');

      // Update Summary / Advice section
      const kSummaryEl = $('k_summary');
      if (kSummaryEl) {
        kSummaryEl.innerHTML = `
          <div class="mb-2"><strong>Verdict:</strong> ${verdict}</div>
          <div class="small">
            <strong>Core Mix:</strong> ${cfg.numPerf}P / ${cfg.numEff}E / ${cfg.numAI}AI / ${cfg.numHyper}H / ${cfg.numGPU}GPU<br/>
            <strong>Clocks:</strong> Perf:${cfg.clkPerf}GHz, Eff:${cfg.clkEff}GHz, Hyper:${cfg.clkHyper}GHz, NPU:${cfg.clkNPU}GHz, GPU:${cfg.clkGPU}GHz<br/>
            <strong>Shader Units:</strong> ${cfg.numShaders} &nbsp;|&nbsp;
            <strong>Complexity:</strong> ${cfg.shaderComplexity} &nbsp;|&nbsp;
            <strong>Shader GFLOPS:</strong> ${fmt(shaderGFLOPS, 2)}<br/>
            <strong>Process Node:</strong> ${cfg.nodeNm} nm &nbsp;|&nbsp; <strong>Battery:</strong> ${cfg.battmAh} mAh<br/>
            <strong>Cooling Budget:</strong> ${cfg.coolingW} W &nbsp;|&nbsp; <strong>System Memory:</strong> ${cfg.sysMem} MB<br/>
            <strong>Throttling:</strong> ${cfg.disableThrottling ? '<span class="warning">DISABLED</span>' : '<span class="success">ENABLED</span>'}<br/>
            <strong>Workload:</strong> ${cfg.workloadProfile}
          </div>
          <div class="small mt-1">
            Battery Life (Mixed Use): <strong>${hMixed.toFixed(1)} h</strong> &nbsp;|&nbsp;
            Temperature: <strong>${tPost.toFixed(0)}°C</strong> &nbsp;|&nbsp;
            Throttle Level: <strong>${throttlePercent.toFixed(0)}%</strong> &nbsp;|&nbsp;
            Composite Score: <strong>${bench.toLocaleString()}</strong><br/>
            GPU TFLOPS: <strong>${fmt(effGPU, 2)}</strong>
          </div>
          <div class="small mt-2">
            <strong>R0 (Algorithmic Base):</strong> Runtime ${r0_ms.toFixed(1)} ms, ${r0_flops.toFixed(1)} FLOPs, ${peakMB.toFixed(1)} MB Peak Mem<br/>
            <strong>R1 (Hardware Potential):</strong> Theoretical ${r1_theoGF.toFixed(1)} GFLOPs, ${r1_theoTOPS.toFixed(1)} TOPS, ${r1_theoGPU.toFixed(1)} TFLOPs (pre-throttling)<br/>
            <strong>R2 (Effective Performance):</strong> Achieved ${effGF.toFixed(1)} GFLOPs, ${effTOPS.toFixed(1)} TOPS, ${effGPU.toFixed(1)} TFLOPs (real-world)
          </div>
          <div class="small mt-2">
            <strong>Specialization:</strong><br/>
            <ul>${specialization.map(s => `<li>${s}</li>`).join('')}</ul>
          </div>
          <div class="small mt-2">
              <strong>Algorithm Efficiency:</strong> ${(algEff * 100).toFixed(1)}% <span class="help">(Compares your algorithm's FLOPs to ideal)</span>
          </div>
          <div class="small mt-2">
              ${archAlignmentAdvice}
              ${optimalDataBlockSizeKB ? `<span class="help">Algorithm optimal data block size: ${optimalDataBlockSizeKB.toFixed(0)} KB</span>` : ''}
          </div>
          <div class="small mt-2">${flopAdvice}</div>
          <div class="small mt-2">${thermalWarning}</div>
          <div class="small mt-2">${errorRisk}</div>
          <div class="small mt-2">${runtimeImpactMessage}</div>
        `;
      }

      // Update Chip Price Estimate
      const totalPrice = calculatePrice(cfg);
      const pEstimateEl = $('p_estimate');
      if (pEstimateEl) {
        pEstimateEl.innerHTML = `
          <div class="small">
            <strong>Estimated Price:</strong> $${totalPrice.toFixed(2)}
          </div>
        `;
      }

      // Calculate Performance Per Watt (PPW) for chart
      const safep = v => (isNaN(v) || !isFinite(v) || v <= 0) ? 0 : v; // Safe division helper
      const ppwLight = safep(bench / pLight);
      const ppwMixed = safep(bench / pMixed);
      const ppwHeavy = safep(bench / pHeavy);
      lastChartData = [ppwLight, ppwMixed, ppwHeavy]; // Store for chart updates
      
      // Update Chart.js data and scale
      if (ppwChart) {
          ppwChart.data.datasets[0].data = lastChartData;
          ppwChart.options.scales.y.type = chartIsLog ? 'logarithmic' : 'linear';
          ppwChart.update();
      }
      
      // Update chart descriptions
      const chartDescriptionsEl = $('chartDescriptions');
      if (chartDescriptionsEl) {
          chartDescriptionsEl.innerHTML = evaluateChartData(lastChartData).map(desc => `<p>${desc}</p>`).join('');
      }

    } catch(e) {
      // Catch and display any simulation errors
      await showCustomAlert('Simulation error: ' + e.message, 'Simulation Error');
      console.error(e);
    } finally {
      // Always hide loading overlay when simulation finishes or errors
      const loadingOverlay = $('loadingOverlay');
      if (loadingOverlay) loadingOverlay.style.display = 'none';
    }
  }

  // --- Event Listeners and Initialization ---
  window.addEventListener('load', () => {
    // DVFS slider and value update
    const dvfsCapEl = $('dvfsCap');
    const dvfsValEl = $('dvfsVal');
    if (dvfsCapEl && dvfsValEl) {
      dvfsValEl.innerText = dvfsCapEl.value + ' MHz';
      dvfsCapEl.addEventListener('input', () => {
        dvfsValEl.innerText = dvfsCapEl.value + ' MHz';
      });
    }

    // Process node performance meter update
    const nodeNmEl = $('nodeNm');
    if (nodeNmEl) {
      nodeNmEl.addEventListener('input', () => {
        updateNodePerfMeter(parseInt(nodeNmEl.value));
      });
    }

    // Set initial algorithm JSON and render saved list
    setAlgorithmJson(DEFAULT_ALGORITHM_JSON);
    renderSavedList();
    applyConfigToUI(DEFAULT); // Apply default config on load
    initChart(); // Initialize chart

    // Button event listeners
    const btnRunEl = $('btnRun');
    if (btnRunEl) btnRunEl.onclick = () => runSimulation().catch(e => console.error(e)); // Run simulation on click

    const btnRefreshChartEl = $('btnRefreshChart');
    if (btnRefreshChartEl) btnRefreshChartEl.onclick = () => {
      if (ppwChart) {
        ppwChart.update(); // Force chart update
      }
      const chartDescriptionsEl = $('chartDescriptions');
      if (chartDescriptionsEl) {
          chartDescriptionsEl.innerHTML = evaluateChartData(lastChartData).map(desc => `<p>${desc}</p>`).join('');
      }
    };

    const btnToggleChartModeEl = $('btnToggleChartMode');
    if (btnToggleChartModeEl) btnToggleChartModeEl.onclick = () => {
      chartIsLog = !chartIsLog; // Toggle chart scale
      initChart(); // Re-initialize chart with new scale
      if(ppwChart){
        ppwChart.data.datasets[0].data = lastChartData;
        ppwChart.update();
      }
      const chartDescriptionsEl = $('chartDescriptions');
      if (chartDescriptionsEl) {
          chartDescriptionsEl.innerHTML = evaluateChartData(lastChartData).map(desc => `<p>${desc}</p>`).join('');
      }
    };

    const btnSaveEl = $('btnSave');
    if (btnSaveEl) btnSaveEl.onclick = async () => {
      await showCustomConfirm('Name this chip (no special chars):', 'Save Chip',
        (name) => {
          if (!name) {
            showCustomAlert('Chip name cannot be empty.', 'Error');
            return;
          }
          const cfg = packConfig();
          const ok = saveChip(name, cfg);
          if(ok){ showCustomAlert('Saved as '+name, 'Success'); const chipTagEl = $('chipTag'); if (chipTagEl) chipTagEl.innerText = name; renderSavedList(); }
          else showCustomAlert('Save failed (storage?).', 'Error');
        },
        () => {}, // Cancel callback
        true // Show input field
      );
    };
    const btnListSaveEl = $('btnListSave');
    if (btnListSaveEl) btnListSaveEl.onclick = renderSavedList;

    const btnClearAllEl = $('btnClearAll');
    if (btnClearAllEl) btnClearAllEl.onclick = clearSaved;

    const btnExportJSONEl = $('btnExportJSON');
    if (btnExportJSONEl) btnExportJSONEl.onclick = () => {
      const cfg = packConfig();
      const blob = new Blob([JSON.stringify(cfg,null,2)], {type:'application/json'});
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url; a.download = 'chip_export.json'; a.click();
      setTimeout(() => URL.revokeObjectURL(url), 2000); // Clean up URL object
    };
    const btnCompareEl = $('btnCompare');
    if (btnCompareEl) btnCompareEl.onclick = async () => {
      const names = listSavedChips();
      if(!names.length) return await showCustomAlert('No saved chips to compare.', 'No Chips');
      await showCustomConfirm('Type name to compare:\\n' + names.join('\\n'), 'Compare Chips',
        async (name) => {
          if (!name) return;
          const cfg = loadChip(name);
          if(!cfg) return await showCustomAlert('Chip "' + name + '" not found.', 'Error');
          compareWithCurrent(cfg, name);
        },
        () => {},
        true
      );
    };
    const btnPresetEl = $('btnPreset');
    if (btnPresetEl) btnPresetEl.onclick = async () => {
      await showCustomConfirm('Choose preset: mid, flag, ultra (type name)', 'Load Preset',
        (sel) => {
          if(!sel) return;
          if(sel==='mid') {
            applyConfigToUI({numPerf:2,numEff:6,numAI:1,numHyper:0,numGPU:4,clkPerf:2.7,clkEff:1.8,clkHyper:4,clkNPU:1.2,clkGPU:1.0,nodeNm:6,battmAh:5000,sysMem:6144,matN:192,layers:5,coolingW:5.5,dvfsCapMHz:3600,quantMode:'fp16',weightFormat:'fp16',disableThrottling:false,workloadProfile:'mixed', thermalLimit: 85, algorithmJson: DEFAULT_ALGORITHM_JSON});
          } else if(sel==='flag') {
            applyConfigToUI({numPerf:4,numEff:4,numAI:2,numHyper:1,numGPU:12,clkPerf:3.1,clkEff:2.0,clkHyper:2.5,clkNPU:1.5,clkGPU:1.8,nodeNm:4,battmAh:5000,sysMem:8192,matN:256,layers:6,coolingW:7.5,dvfsCapMHz:4200,quantMode:'fp16',weightFormat:'fp16',disableThrottling:false,workloadProfile:'mixed', thermalLimit: 85, algorithmJson: BLOCKED_ALGORITHM_JSON});
          } else if(sel==='ultra') {
            applyConfigToUI({numPerf:6,numEff:2,numAI:3,numHyper:1,numGPU:16,clkPerf:3.4,clkEff:2.2,clkHyper:2.8,clkNPU:1.7,clkGPU:2.2,nodeNm:3,battmAh:6000,sysMem:12288,matN:320,layers:7,coolingW:9.0,dvfsCapMHz:4400,quantMode:'int8',weightFormat:'fp16',disableThrottling:false,workloadProfile:'mixed', thermalLimit: 90, algorithmJson: BATTERY_OPTIMIZED_ALGORITHM_JSON});
          } else {
            showCustomAlert('Unknown preset. Type mid, flag, or ultra.', 'Invalid Preset');
          }
        },
        () => {},
        true
      );
    };
    const btnResetEl = $('btnReset');
    if (btnResetEl) btnResetEl.onclick = () => applyConfigToUI(DEFAULT);

    const btnQuickHelpEl = $('btnQuickHelp');
    if (btnQuickHelpEl) btnQuickHelpEl.onclick = () => showCustomAlert(
      `Quick Help:
- Define your algorithm as JSON in the 'Editable Math Architecture' box.
- Press Run Simulation to measure the chip's runtime and get realistic metrics.
- Use quantization and weight format to affect AI throughput and memory.
- DVFS slider limits peak clock frequency; thermal pressure will reduce clocks further.
- Save/Load allows sharing and comparison via localStorage or JSON export.
- Disable Thermal Throttling to see raw performance at risk of overheating.
- Select a Workload Profile to test performance under different usage scenarios.`, 'Quick Help');
    const btnAboutEl = $('btnAbout');
    if (btnAboutEl) btnAboutEl.onclick = () => showCustomAlert('Prime Edition — Fictional Phone Chip Simulator\\nBuilt to be robust and flexible. All numbers are abstracted for play and realism, not a hardware-grade simulator.', 'About');

    const btnCostOptimizeEl = $('btnCostOptimize');
    if (btnCostOptimizeEl) btnCostOptimizeEl.onclick = async () => {
      await showCustomAlert(`Cost Optimization Mode (Feature coming soon!):
This mode would suggest adjustments to your chip (e.g., lower core counts, older process node) to reduce the 'Chip Price Estimate' while trying to stay within a user-defined performance band.`, 'Cost Optimization');
    };

    // --- Algorithm Editor related functions ---
    const btnLoadDefaultAlgorithmEl = $('btnLoadDefaultAlgorithm');
    if (btnLoadDefaultAlgorithmEl) btnLoadDefaultAlgorithmEl.onclick = () => setAlgorithmJson(DEFAULT_ALGORITHM_JSON);
    
    const btnLoadBlockedAlgorithmEl = $('btnLoadBlockedAlgorithm');
    if (btnLoadBlockedAlgorithmEl) btnLoadBlockedAlgorithmEl.onclick = () => setAlgorithmJson(BLOCKED_ALGORITHM_JSON);

    const btnLoadBatteryOptimizedAlgorithmEl = $('btnLoadBatteryOptimizedAlgorithm');
    if (btnLoadBatteryOptimizedAlgorithmEl) btnLoadBatteryOptimizedAlgorithmEl.onclick = () => setAlgorithmJson(BATTERY_OPTIMIZED_ALGORITHM_JSON);
    
    const btnBeautifyAlgorithmEl = $('btnBeautifyAlgorithm');
    if (btnBeautifyAlgorithmEl) btnBeautifyAlgorithmEl.onclick = () => {
      const algorithmEditorEl = $('algorithmEditor');
      if (algorithmEditorEl) algorithmEditorEl.value = beautifyJson(algorithmEditorEl.value);
    };

    // New Tutorial Modal Logic
    const btnAlgorithmTutorialEl = $('btnAlgorithmTutorial');
    if (btnAlgorithmTutorialEl) btnAlgorithmTutorialEl.onclick = () => {
      // This will open a new tab with a fictional tutorial page;
      // in a real scenario, you'd provide the actual URL to the tutorial.
      window.open('algorithm_design_tutorial', '_blank');
    };
    
    // Existing Tuning Guide Modal Logic
    const btnTuningGuideEl = $('btnTuningGuide');
    if (btnTuningGuideEl) btnTuningGuideEl.onclick = () => {
      const tuningGuideModalEl = $('tuningGuideModal');
      if (tuningGuideModalEl) tuningGuideModalEl.classList.remove('hidden');
    };
    const closeTuningGuideEl = $('closeTuningGuide');
    if (closeTuningGuideEl) closeTuningGuideEl.onclick = () => {
      const tuningGuideModalEl = $('tuningGuideModal');
      if (tuningGuideModalEl) tuningGuideModalEl.classList.add('hidden');
    };

    // Initial simulation run after a short delay to allow UI to render
    setTimeout(() => {
      runSimulation().catch(e => console.error(e));
    }, 120);
  });
})();
</script>
</body>
</html>
